// -*- C++ -*-
//===----------------------------- buffer ---------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//  Based on N4332
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_BUFFER
#define _LIBCPP_EXPERIMENTAL_BUFFER

/* 
    io_service synopsis

namespace std {
  namespace experimental {
    inline namespace network_v1 {

      enum class stream_errc {
        eof = implementation defined,
        not_found = implementation defined
      };

      const error_category& stream_category() noexcept;

      error_code make_error_code(stream_errc e) noexcept;
      error_condition make_error_condition(stream_errc e) noexcept;

      class mutable_buffer;

      class const_buffer;

      class mutable_buffers_1;

      class const_buffers_1;

      // buffer type traits:

      template<class T> is_mutable_buffer_sequence;
      template<class T> is_const_buffer_sequence;
      template<class T> is_dynamic_buffer_sequence;

      // buffer conversions:

      template<class T> T buffer_cast(const mutable_buffer& b) noexcept;
      template<class T> T buffer_cast(const const_buffer& b) noexcept;

      // buffer size:

      size_t buffer_size(const mutable_buffer& b) noexcept;
      size_t buffer_size(const const_buffer& b) noexcept;
      template<class ConstBufferSequence>
        size_t buffer_size(const ConstBufferSequence& buffers) noexcept;

      // buffer copy:

      size_t buffer_copy(const mutable_buffer& dest,
                         const const_buffer& source) noexcept;
      size_t buffer_copy(const mutable_buffer& dest,
                         const const_buffer& source,
                         size_t max_size) noexcept;
      template<class ConstBufferSequence>
        size_t buffer_copy(const mutable_buffer& dest,
                           const ConstBufferSequence& source) noexcept;
      template<class ConstBufferSequence>
        size_t buffer_copy(const mutable_buffer& dest,
                           const ConstBufferSequence& source,
                           size_t max_size) noexcept;
      template<class MutableBufferSequence>
        size_t buffer_copy(const MutableBufferSequence& dest,
                           const const_buffer& source) noexcept;
      template<class MutableBufferSequence>
        size_t buffer_copy(const MutableBufferSequence& dest,
                           const const_buffer& source,
                           size_t max_size) noexcept;
      template<class MutableBufferSequence, class ConstBufferSequence>
        size_t buffer_copy(const MutableBufferSequence& dest,
                           const ConstBufferSequence& source) noexcept;
      template<class MutableBufferSequence, class ConstBufferSequence>
        size_t buffer_copy(const MutableBufferSequence& dest,
                           const ConstBufferSequence& source,
                           max_size) noexcept;

      // buffer arithmetic:

      mutable_buffer operator+(const mutable_buffer& b, size_t n) noexcept;
      mutable_buffer operator+(size_t n, const mutable_buffer& b) noexcept;
      const_buffer operator+(const const_buffer&, size_t n) noexcept;
      const_buffer operator+(size_t, const const_buffer&) noexcept;
      mutable_buffers_1 operator+(const mutable_buffers_1& b, size_t n) noexcept;
      mutable_buffers_1 operator+(size_t n, const mutable_buffers_1& b) noexcept;
      const_buffers_1 operator+(const const_buffers_1&, size_t n) noexcept;
      const_buffers_1 operator+(size_t, const const_buffers_1&) noexcept;

      // buffer creation:

      mutable_buffers_1 buffer(void* p, size_t n) noexcept;
      const_buffers_1 buffer(const void* p, size_t n) noexcept;

      mutable_buffers_1 buffer(const mutable_buffer& b) noexcept;
      mutable_buffers_1 buffer(const mutable_buffer& b, size_t n) noexcept;
      const_buffers_1 buffer(const const_buffer& b) noexcept;
      const_buffers_1 buffer(const const_buffer& b, size_t n) noexcept;

      template<class T, size_t N>
        mutable_buffers_1 buffer(T (&arr)[N]) noexcept;
      template<class T, size_t N>
        mutable_buffers_1 buffer(T (&arr)[N], size_t n) noexcept;
      template<class T, size_t N>
        const_buffers_1 buffer(const T (&arr)[N]) noexcept;
      template<class T, size_t N>
        const_buffers_1 buffer(const T (&arr)[N], size_t n) noexcept;

      template<class T, size_t N>
        mutable_buffers_1 buffer(array<T, N>& arr) noexcept;
      template<class T, size_t N>
        mutable_buffers_1 buffer(array<T, N>& arr, size_t n) noexcept;
      template<class T, size_t N>
        const_buffers_1 buffer(array<const T, N>& arr) noexcept;
      template<class T, size_t N>
        const_buffers_1 buffer(array<const T, N>& arr, size_t n) noexcept;
      template<class T, size_t N>
        const_buffers_1 buffer(const array<T, N>& arr) noexcept;
      template<class T, size_t N>
        const_buffers_1 buffer(const array<T, N>& arr, size_t n) noexcept;

      template<class T, class Allocator>
        mutable_buffers_1 buffer(vector<T, Allocator>& vec) noexcept;
      template<class T, class Allocator>
        mutable_buffers_1 buffer(vector<T, Allocator>& vec, size_t n) noexcept;
      template<class T, class Allocator>
        const_buffers_1 buffer(const vector<T, Allocator>& vec) noexcept;
      template<class T, class Allocator>
        const_buffers_1 buffer(const vector<T, Allocator>& vec, size_t n) noexcept;

      template<class CharT, class Traits, class Allocator>
        mutable_buffers_1 buffer(basic_string<CharT, Traits, Allocator>& str) noexcept;
      template<class CharT, class Traits, class Allocator>
        mutable_buffers_1 buffer(basic_string<CharT, Traits, Allocator>& str,
                                 size_t n) noexcept;
      template<class CharT, class Traits, class Allocator>
        const_buffers_1 buffer(const basic_string<CharT, Traits, Allocator>& str) noexcept;
      template<class CharT, class Traits, class Allocator>
        const_buffers_1 buffer(const basic_string<CharT, Traits, Allocator>& str,
                               size_t n) noexcept;

      template<class CharT, class Traits>
        const_buffers_1 buffer(const basic_string_view<CharT, Traits>& str) noexcept;
      template<class CharT, class Traits, class Allocator>
        const_buffers_1 buffer(const basic_string_view<CharT, Traits>& str,
                               size_t n) noexcept;

      template<class T, Allocator>
        class dynamic_vector_buffer;

      template<class CharT, class Traits, Allocator>
        class dynamic_string_buffer;

      // dynamic buffer creation:

      template<class T, class Allocator>
        dynamic_vector_buffer<T, Allocator>
          dynamic_buffer(vector<T, Allocator>& vec) noexcept;
      template<class T, class Allocator>
        dynamic_vector_buffer<T, Allocator>
          dynamic_buffer(vector<T, Allocator>& vec, size_t n) noexcept;

      template<class CharT, class Traits, class Allocator>
        dynamic_string_buffer<CharT, Traits, Allocator>
          dynamic_buffer(basic_string<CharT, Traits, Allocator>& str) noexcept;
      template<class CharT, class Traits, class Allocator>
        dynamic_string_buffer<CharT, Traits, Allocator>
          dynamic_buffer(basic_string<CharT, Traits, Allocator>& str, size_t n) noexcept;

      class transfer_all;
      class transfer_at_least;
      class transfer_exactly;

      // synchronous read operations:

      template<class SyncReadStream, class MutableBufferSequence>
        size_t read(SyncReadStream& stream,
                    const MutableBufferSequence& buffers);
      template<class SyncReadStream, class MutableBufferSequence>
        size_t read(SyncReadStream& stream,
                    const MutableBufferSequence& buffers, error_code& ec);
      template<class SyncReadStream, class MutableBufferSequence,
        class CompletionCondition>
          size_t read(SyncReadStream& stream,
                      const MutableBufferSequence& buffers,
                      CompletionCondition completion_condition);
      template<class SyncReadStream, class MutableBufferSequence,
        class CompletionCondition>
          size_t read(SyncReadStream& stream,
                      const MutableBufferSequence& buffers,
                      CompletionCondition completion_condition,
                      error_code& ec);
      template<class SyncReadStream, class DynamicBufferSequence>
        size_t read(SyncReadStream& stream, DynamicBufferSequence&& b);
      template<class SyncReadStream, class DynamicBufferSequence>
        size_t read(SyncReadStream& stream, DynamicBufferSequence&& b,
                    error_code& ec);
      template<class SyncReadStream, class DynamicBufferSequence,
        class CompletionCondition>
          size_t read(SyncReadStream& stream, DynamicBufferSequence&& b,
                      CompletionCondition completion_condition);
      template<class SyncReadStream, class DynamicBufferSequence,
        class CompletionCondition>
          size_t read(SyncReadStream& stream, DynamicBufferSequence&& b,
                      CompletionCondition completion_condition,
                      error_code& ec);

      // asynchronous read operations:

      template<class AsyncReadStream, class MutableBufferSequence,
        class CompletionToken>
          auto async_read(AsyncReadStream& stream,
                          const MutableBufferSequence& buffers,
                          CompletionToken&& token);
      template<class AsyncReadStream, class MutableBufferSequence,
        class CompletionCondition, class CompletionToken>
          auto async_read(AsyncReadStream& stream,
                          const MutableBufferSequence& buffers,
                          CompletionCondition completion_condition,
                          CompletionToken&& token);
      template<class AsyncReadStream, class DynamicBufferSequence,
        class CompletionToken>
          auto async_read(AsyncReadStream& stream,
                          DynamicBufferSequence&& b,
                          CompletionToken&& token);
      template<class AsyncReadStream, class DynamicBufferSequence,
        class CompletionCondition, class CompletionToken>
          auto async_read(AsyncReadStream& stream,
                          DynamicBufferSequence&& b,
                          CompletionCondition completion_condition,
                          CompletionToken&& token);

      // synchronous write operations:

      template<class SyncWriteStream, class ConstBufferSequence>
        size_t write(SyncWriteStream& stream,
                     const ConstBufferSequence& buffers);
      template<class SyncWriteStream, class ConstBufferSequence>
        size_t write(SyncWriteStream& stream,
                     const ConstBufferSequence& buffers, error_code& ec);
      template<class SyncWriteStream, class ConstBufferSequence,
        class CompletionCondition>
          size_t write(SyncWriteStream& stream,
                       const ConstBufferSequence& buffers,
                       CompletionCondition completion_condition);
      template<class SyncWriteStream, class ConstBufferSequence,
        class CompletionCondition>
          size_t write(SyncWriteStream& stream,
                       const ConstBufferSequence& buffers,
                       CompletionCondition completion_condition,
                       error_code& ec);
      template<class SyncWriteStream, class DynamicBufferSequence>
        size_t write(SyncWriteStream& stream, DynamicBufferSequence&& b);
      template<class SyncWriteStream, class DynamicBufferSequence>
        size_t write(SyncWriteStream& stream, DynamicBufferSequence&& b,
                     error_code& ec);
      template<class SyncWriteStream, class DynamicBufferSequence,
        class CompletionCondition>
          size_t write(SyncWriteStream& stream,
                       DynamicBufferSequence&& b,
                       CompletionCondition completion_condition);
      template<class SyncWriteStream, class DynamicBufferSequence,
        class CompletionCondition>
          size_t write(SyncWriteStream& stream,
                       DynamicBufferSequence&& b,
                       CompletionCondition completion_condition,
                       error_code& ec);

      // asynchronous write operations:

      template<class AsyncWriteStream, class ConstBufferSequence,
        class CompletionToken>
          auto async_write(AsyncWriteStream& stream,
                           const ConstBufferSequence& buffers,
                           CompletionToken&& token);
      template<class AsyncWriteStream, class ConstBufferSequence,
        class CompletionCondition, class CompletionToken>
          auto async_write(AsyncWriteStream& stream,
                           const ConstBufferSequence& buffers,
                           CompletionCondition completion_condition,
                           CompletionToken&& token);
      template<class AsyncWriteStream, class DynamicBufferSequence,
        class CompletionToken>
          auto async_write(AsyncWriteStream& stream,
                           DynamicBufferSequence&& b,
                           CompletionToken&& token);
      template<class AsyncWriteStream, class DynamicBufferSequence,
        class CompletionCondition, class CompletionToken>
          auto async_write(AsyncWriteStream& stream,
                           DynamicBufferSequence&& b,
                           CompletionCondition completion_condition,
                           CompletionToken&& token);

      // synchronous delimited read operations:

      template<class SyncReadStream, class DynamicBufferSequence>
        size_t read_until(SyncReadStream& s, DynamicBufferSequence&& b,
                          char delim);
      template<class SyncReadStream, class DynamicBufferSequence>
        size_t read_until(SyncReadStream& s, DynamicBufferSequence&& b,
                          char delim, error_code& ec);
      template<class SyncReadStream, class DynamicBufferSequence>
        size_t read_until(SyncReadStream& s, DynamicBufferSequence&& b,
                          const string_view& delim);
      template<class SyncReadStream, class DynamicBufferSequence>
        size_t read_until(SyncReadStream& s, DynamicBufferSequence&& b,
                          const string_view& delim, error_code& ec);

      // asynchronous delimited read operations:

      template<class AsyncReadStream, class DynamicBufferSequence,
        class CompletionToken>
          auto async_read_until(AsyncReadStream& s,
                                DynamicBufferSequence&& b, char delim,
                                CompletionToken&& token);
      template<class AsyncReadStream, class DynamicBufferSequence,
        class CompletionToken>
          auto async_read_until(AsyncReadStream& s,
                                DynamicBufferSequence&& b,
                                const string_view& delim,
                                CompletionToken&& token);

    } // inline namespace network_v1
  } // namespace experimental

  template<> struct is_error_code_enum<
    experimental::network_v1::stream_errc>
      : public true_type {};

} // namespace std

*/


#include <experimental/__net_config>
#include <system_error>
#include <stdexcept>
#include <string>

#include <experimental/string_view>

_LIBCPP_BEGIN_NAMESPACE_NETWORK

enum class stream_errc { // TODO need real values here
    eof       = 0x12345, // implementation defined,
    not_found = 0x12346  // implementation defined
};

const _VSTD::error_category& stream_category() noexcept;

 _VSTD::error_code make_error_code(stream_errc __e) noexcept
 { return _VSTD::error_code(static_cast<int>(__e), stream_category()); }
 
_VSTD::error_condition make_error_condition(stream_errc __e) noexcept
 { return _VSTD::error_condition(static_cast<int>(__e), stream_category()); }

class mutable_buffer
{
public:
    mutable_buffer() noexcept : __data(nullptr), __size(0) {}
    mutable_buffer(void* __p, size_t __n) noexcept : __data(__p), __size(__n) {}
    
//  Marshall's extensions
    void * data() const { return __data; }
    size_t size() const { return __size; }

private:
    void*  __data;
    size_t __size;
};

class const_buffer
{
public:
    const_buffer() noexcept : __data(nullptr), __size(0) {}
    const_buffer(const void* __p, size_t __n) noexcept : __data(__p), __size(__n) {}
    const_buffer(const mutable_buffer &__b) noexcept : __data(__b.data()), __size(__b.size()) {}

//  Marshall's extensions
    const void * data() const { return __data; }
    size_t       size() const { return __size; }

private:
    const void*  __data;
          size_t __size;
};

class mutable_buffers_1;

// An object of class const_buffers_1 represents a sequence of exactly one const_buffer object.
// The const_buffers_1 class meets the requirements for ConstBufferSequence and ConvertibleToConstBuffer.
class const_buffers_1 : public const_buffer
{
public:
    typedef const_buffer value_type;
    typedef const value_type *const_iterator;

    const_buffers_1(const void* __p, size_t __n) noexcept : const_buffer(__p, __n) {}
    explicit const_buffers_1(const const_buffer& __b) noexcept : const_buffer(__b) {}

    const_iterator begin() const noexcept { return this; }
    const_iterator end()   const noexcept { return begin() + 1; }
};

// An object of class mutable_buffers_1 represents a sequence of exactly one mutable_buffer object.
// The mutable_buffers_1 class meets the requirements for MutableBufferSequence, 
//    ConstBufferSequence, ConvertibleToMutableBuffer, and ConvertibleToConstBuffer.
class mutable_buffers_1 : public mutable_buffer
{
public:
    typedef mutable_buffer value_type;
    typedef const value_type *const_iterator;

    mutable_buffers_1(void* __p, size_t __n) noexcept : mutable_buffer(__p, __n) {}
    explicit mutable_buffers_1(const mutable_buffer& __b) noexcept : mutable_buffer(__b) {}

    const_iterator begin() const noexcept { return this; }
    const_iterator end()   const noexcept { return begin() + 1; }
};



// buffer type traits:
template<class T> struct is_mutable_buffer_sequence  : public _VSTD::true_type {}; // TODO
template<class T> struct is_const_buffer_sequence    : public _VSTD::true_type {}; // TODO
template<class T> struct is_dynamic_buffer_sequence  : public _VSTD::true_type {}; // TODO

// buffer conversions:
template<class _Tp>
_Tp buffer_cast(const const_buffer& __b) noexcept   { return static_cast<_Tp>(__b.data()); }

template<class _Tp>
_Tp buffer_cast(const mutable_buffer& __b) noexcept { return static_cast<_Tp>(__b.data()); }

// buffer size:
size_t buffer_size(const const_buffer&   __b) noexcept { return __b.size(); }
size_t buffer_size(const mutable_buffer& __b) noexcept { return __b.size(); }

mutable_buffer operator+(const mutable_buffer& __b, size_t __n) noexcept
{
    size_t __sz = _VSTD::min(buffer_size(__b), __n);
    return mutable_buffer(buffer_cast<char *>(__b) + __sz, buffer_size(__b) - __sz);
}
mutable_buffer operator+(size_t __n, const mutable_buffer& __b) noexcept { return __b + __n; }

const_buffer operator+(const const_buffer& __b, size_t __n) noexcept
{
    size_t __sz = _VSTD::min(buffer_size(__b), __n);
    return const_buffer(buffer_cast<const char *>(__b) + __sz, buffer_size(__b) - __sz);
}
const_buffer operator+(size_t __n, const const_buffer& __b) noexcept { return __b + __n; }

mutable_buffers_1 operator+(const mutable_buffers_1& __b, size_t __n) noexcept
{
    size_t __sz = _VSTD::min(buffer_size(__b), __n);
    return mutable_buffers_1(buffer_cast<char *>(__b) + __sz, buffer_size(__b) - __sz);
}
mutable_buffers_1 operator+(size_t __n, const mutable_buffers_1& __b) noexcept { return __b + __n; }

const_buffers_1 operator+(const const_buffers_1& __b, size_t __n) noexcept
{
    size_t __sz = _VSTD::min(buffer_size(__b), __n);
    return const_buffers_1(buffer_cast<const char *>(__b) + __sz, buffer_size(__b) - __sz);
}
const_buffers_1 operator+(size_t __n, const const_buffers_1& __b) noexcept { return __b + __n; }


template <class _ConstBufferSequence>
typename _VSTD::enable_if<is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
buffer_size(const _ConstBufferSequence& __bs) noexcept
{
    size_t __total = 0;
    for (const auto& __v: __bs)
        __total += buffer_size(const_buffer(__v));
    return __total;
}


size_t buffer_copy(const mutable_buffer& __d, const const_buffer& __s) noexcept
{
    size_t __ret = _VSTD::min(buffer_size(__s), buffer_size(__d));
    _VSTD::memcpy(buffer_cast<void *>(__d), buffer_cast<const void *>(__s), __ret);
    return __ret;
}

size_t buffer_copy(const mutable_buffer& __d, const const_buffer& __s, size_t __max) noexcept
{
    size_t __ret = _VSTD::min(__max,
                   _VSTD::min(buffer_size(__s), buffer_size(__d)));
    _VSTD::memcpy(buffer_cast<void *>(__d), buffer_cast<const void *>(__s), __ret);
    return __ret;
}

template<class _ConstBufferSequence>
size_t buffer_copy(const mutable_buffer& __d, const _ConstBufferSequence& __s, size_t __max) noexcept
{
    mutable_buffer __temp = __d;
    size_t __space = _VSTD::min(buffer_size(__temp), __max);
    size_t __n = 0;
    for ( typename _ConstBufferSequence::const_iterator __iter = __s.begin();
            __space > 0 && __iter != __s.end(); ++__iter, __space -= __n)
    {
        __n = buffer_copy(__temp, *__iter, __space);
        __temp = __temp + __n;
    }
    return buffer_size(__d) - __space;
}

template<class _ConstBufferSequence>
typename _VSTD::enable_if<is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
buffer_copy(const mutable_buffer& __d, const _ConstBufferSequence& __s) noexcept
{ return buffer_copy(__d, __s, _VSTD::numeric_limits<size_t>::max()); }

template<class _MutableBufferSequence>
typename _VSTD::enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value, size_t>::type
buffer_copy(const _MutableBufferSequence& __d, const const_buffer& __s,  size_t __max) noexcept
{
    const_buffer __temp = __s;
    size_t __space = _VSTD::min(__max, buffer_size(__temp));
    size_t __n = 0;
    for ( typename _MutableBufferSequence::const_iterator __iter = __d.begin();
                   __space > 0 && __iter != __d.end(); ++__iter, __space -= __n)
        {
        __n = buffer_copy(*__iter, __temp, __space);
        __temp = __temp + __n;
        }
    return _VSTD::min(__max, buffer_size(__s)) - __space;
}


template<class _MutableBufferSequence>
typename _VSTD::enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value, size_t>::type
buffer_copy(const _MutableBufferSequence& __d, const const_buffer& __s) noexcept
{ return buffer_copy(__d, __s, _VSTD::numeric_limits<size_t>::max()); }


template<class _MutableBufferSequence, class _ConstBufferSequence>
typename _VSTD::enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value
                       && is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
buffer_copy(const _MutableBufferSequence& __d, const _ConstBufferSequence& __s, size_t __max) noexcept
{
    size_t __ret = 0;
    size_t __sOffset = 0;
    size_t __dOffset = 0;
    typename _MutableBufferSequence::const_iterator __dIter  = __d.begin();
    typename _ConstBufferSequence::const_iterator   __sIter  = __s.begin();
    while (__ret < __max && __dIter != __d.end() && __sIter != __s.end())
    {
        typename _ConstBufferSequence::value_type __source = *__sIter + __sOffset;
        typename _MutableBufferSequence::value_type __dest = *__dIter + __dOffset;
        size_t __n = buffer_copy(__dest, __source, __max - __ret);

        if ( __n != buffer_size(__source))
            __sOffset += __n;
        else {
            __sIter++;
            __sOffset = 0;
            }

        if ( __n != buffer_size(__dest))
            __dOffset += __n;
        else {
            __dIter++;
            __dOffset = 0;
            }

        __ret += __n;
    }
    return __ret;
}

template<class _MutableBufferSequence, class _ConstBufferSequence>
typename _VSTD::enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value
                       && is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
buffer_copy(const _MutableBufferSequence& __d, const _ConstBufferSequence& __s) noexcept
{ return buffer_copy(__d, __s, _VSTD::numeric_limits<size_t>::max()); }


mutable_buffers_1 buffer(      void* __p, size_t __n) noexcept { return mutable_buffers_1(__p, __n); }
const_buffers_1   buffer(const void* __p, size_t __n) noexcept { return const_buffers_1  (__p, __n); }
mutable_buffers_1 buffer(const mutable_buffer& __b) noexcept { return mutable_buffers_1(__b); }
const_buffers_1   buffer(const const_buffer&   __b) noexcept { return const_buffers_1  (__b); }

mutable_buffers_1 buffer(const mutable_buffer& __b, size_t __n) noexcept
{ return mutable_buffers_1(buffer_cast<void*>(__b),_VSTD::min(buffer_size(__b), __n)); }

const_buffers_1   buffer(const const_buffer&   __b, size_t __n) noexcept
{ return const_buffers_1  (buffer_cast<const void*>(__b),_VSTD::min(buffer_size(__b), __n)); }

// built-in arrays
template<class _Tp, size_t _N>
mutable_buffers_1 buffer(_Tp (&__arr)[_N]) noexcept
{ return mutable_buffers_1(static_cast<void *>(__arr), _N * sizeof(_Tp)); }

template<class _Tp, size_t _N>
mutable_buffers_1 buffer(_Tp (&__arr)[_N], size_t __n) noexcept
{ return mutable_buffers_1(static_cast<void *>(__arr), _VSTD::min(_N * sizeof(_Tp), __n)); }

template<class _Tp, size_t _N>
const_buffers_1 buffer(const _Tp (&__arr)[_N]) noexcept
{ return const_buffers_1(static_cast<const void *>(__arr), _N * sizeof(_Tp)); }

template<class _Tp, size_t _N>
const_buffers_1 buffer(const _Tp (&__arr)[_N], size_t __n) noexcept
{ return const_buffers_1(static_cast<const void *>(__arr), _VSTD::min(_N * sizeof(_Tp), __n)); }

// std::array 
template<class _Tp, size_t _N>
mutable_buffers_1 buffer(_VSTD::array<_Tp, _N>& __arr) noexcept
{ return mutable_buffers_1(static_cast<void *>(__arr.data()), _N * sizeof(_Tp)); }

template<class _Tp, size_t _N>
mutable_buffers_1 buffer(_VSTD::array<_Tp, _N>& __arr, size_t __n) noexcept
{ return mutable_buffers_1(static_cast<void *>(__arr.data()), _VSTD::min(_N * sizeof(_Tp), __n)); }

template<class _Tp, size_t _N>
const_buffers_1 buffer(_VSTD::array<const _Tp, _N>& __arr) noexcept
{ return const_buffers_1(static_cast<const void *>(__arr.data()), _N * sizeof(_Tp)); }

template<class _Tp, size_t _N>
const_buffers_1 buffer(_VSTD::array<const _Tp, _N>& __arr, size_t __n) noexcept
{ return const_buffers_1(static_cast<const void *>(__arr.data()), _VSTD::min(_N * sizeof(_Tp), __n)); }

template<class _Tp, size_t _N>
const_buffers_1 buffer(const _VSTD::array<_Tp, _N>& __arr) noexcept
{ return const_buffers_1(static_cast<const void *>(__arr.data()), _N * sizeof(_Tp)); }

template<class _Tp, size_t _N>
const_buffers_1 buffer(const _VSTD::array<_Tp, _N>& __arr, size_t __n) noexcept
{ return const_buffers_1(static_cast<const void *>(__arr.data()), _VSTD::min(_N * sizeof(_Tp), __n)); }


// std::vector
template<class _Tp, class _Allocator>
mutable_buffers_1 buffer(_VSTD::vector<_Tp, _Allocator>& __v) noexcept
{ return mutable_buffers_1(static_cast<void *>(__v.data()), __v.size() * sizeof(_Tp)); }

template<class _Tp, class _Allocator>
mutable_buffers_1 buffer(_VSTD::vector<_Tp, _Allocator>& __v, size_t __n) noexcept
{ return mutable_buffers_1(static_cast<void *>(__v.data()), _VSTD::min(__v.size() * sizeof(_Tp), __n)); }

template<class _Tp, class _Allocator>
const_buffers_1 buffer(const _VSTD::vector<_Tp, _Allocator>& __v) noexcept
{ return const_buffers_1(static_cast<const void *>(__v.data()), __v.size() * sizeof(_Tp)); }

template<class _Tp, class _Allocator>
const_buffers_1 buffer(const _VSTD::vector<_Tp, _Allocator>& __v, size_t __n) noexcept
{ return const_buffers_1(static_cast<const void *>(__v.data()), _VSTD::min(__v.size() * sizeof(_Tp), __n)); }

// std::basic_string
template<class _CharT, class _Traits, class _Allocator>
mutable_buffers_1 buffer(_VSTD::basic_string<_CharT, _Traits, _Allocator>& __str) noexcept
{ return mutable_buffers_1(static_cast<void *>(__str.data()), __str.size() * sizeof(_CharT)); }

template<class _CharT, class _Traits, class _Allocator>
mutable_buffers_1 buffer(_VSTD::basic_string<_CharT, _Traits, _Allocator>& __str, size_t __n) noexcept
{ return mutable_buffers_1(static_cast<void *>(__str.data()), _VSTD::min(__str.size() * sizeof(_CharT), __n)); }

template<class _CharT, class _Traits, class _Allocator>
const_buffers_1 buffer(const _VSTD::basic_string<_CharT, _Traits, _Allocator>& __str) noexcept
{ return const_buffers_1(static_cast<const void *>(__str.data()), __str.size() * sizeof(_CharT)); }

template<class _CharT, class _Traits, class _Allocator>
const_buffers_1 buffer(const _VSTD::basic_string<_CharT, _Traits, _Allocator>& __str, size_t __n) noexcept
{ return const_buffers_1(static_cast<const void *>(__str.data()), _VSTD::min(__str.size() * sizeof(_CharT), __n)); }

// std::basic_string_view
template<class _CharT, class _Traits>
const_buffers_1 buffer(const _VSTD_LFTS::basic_string_view<_CharT, _Traits> __sv) noexcept
{ return const_buffers_1(static_cast<const void *>(__sv.data()), __sv.size() * sizeof(_CharT)); }

template<class _CharT, class _Traits>
const_buffers_1 buffer(const _VSTD_LFTS::basic_string_view<_CharT, _Traits> __sv, size_t __n) noexcept
{ return const_buffers_1(static_cast<const void *>(__sv.data()), _VSTD::min(__sv.size() * sizeof(_CharT), __n)); }


template<class _Tp, class _Storage>
class __dynamic_buffer
{
public:
    typedef const_buffers_1   const_buffers_type;
    typedef mutable_buffers_1 mutable_buffers_type;
    
    explicit __dynamic_buffer(_Storage& __vec) noexcept
        : __data(__vec), __size(__vec.size()), __max_size(__vec.max.size()) {}
    __dynamic_buffer(_Storage& __vec, size_t __maximum_size) noexcept
        : __data(__vec), __size(__vec.size()), __max_size(__maximum_size) {}
    __dynamic_buffer(__dynamic_buffer&&) = default;

    size_t size() const noexcept     { return __size; }
    size_t max_size() const noexcept { return __max_size; }
    size_t capacity() const noexcept { return __data.capacity(); }
    const_buffers_type data() const noexcept { return const_buffers_type(__data, __size); }

    mutable_buffers_type prepare(size_t __n)
    {
        if (size() + __n > __max_size)
            throw std::length_error{"dynamic_buffer::prepare"};
        __data.resize(__size + __n);
        return mutable_buffers_type(__data, __size);
    }

    void commit(size_t __n)
    {
        __size += _VSTD::min(__n, __data.size() - __size);
        __data.resize(__size);
    }
    
    void consume(size_t __n)
    {
        size_t __m = _VSTD::min(__n, __size);
        __data.erase(__data.begin(), __data.begin() + __m);
        __size -= __m;
    }

private:
    _Storage&    __data;
    size_t       __size;
    const size_t __max_size;
};

// The dynamic_vector_buffer class template meets the requirements for DynamicBufferSequence.
// The dynamic_vector_buffer class template requires that T is a POD type and that sizeof(T) == 1.
template<class _Tp, class _Allocator>
using dynamic_vector_buffer = __dynamic_buffer<_Tp, _VSTD::vector<_Tp, _Allocator>>;

// The dynamic_vector_buffer class template meets the requirements for DynamicBufferSequence.
// The dynamic_string_buffer class template requires that sizeof(CharT) == 1.
template<class _CharT, class _Traits, class _Allocator>
using dynamic_string_buffer = __dynamic_buffer<_CharT, _VSTD::basic_string<_CharT, _Traits, _Allocator>>;

// dynamic buffer creation:
template<class _Tp, class _Allocator>
dynamic_vector_buffer<_Tp, _Allocator>
dynamic_buffer(vector<_Tp, _Allocator>& __vec) noexcept
{ return dynamic_vector_buffer<_Tp, _Allocator>(__vec); }

template<class _Tp, class _Allocator>
dynamic_vector_buffer<_Tp, _Allocator> 
dynamic_buffer(vector<_Tp, _Allocator>& __vec, size_t __n) noexcept
{ return dynamic_vector_buffer<_Tp, _Allocator>(__vec, __n); }

template<class _CharT, class _Traits, class _Allocator>
dynamic_string_buffer<_CharT, _Traits, _Allocator>
dynamic_buffer(basic_string<_CharT, _Traits, _Allocator>& __str) noexcept
{  return dynamic_string_buffer<_CharT, _Traits, _Allocator>(__str); }

template<class _CharT, class _Traits, class _Allocator>
dynamic_string_buffer<_CharT, _Traits, _Allocator>
dynamic_buffer(basic_string<_CharT, _Traits, _Allocator>& __str, size_t __n) noexcept
{  return dynamic_string_buffer<_CharT, _Traits, _Allocator>(__str, __n); }

enum { __default_transfer_size = 0x10000 }; // TODO - pick a real #, not just a guess

class transfer_all
{
public:
    size_t operator()(const _VSTD::error_code& __ec, size_t) const
                                        { return !__ec ? 0 : __default_transfer_size; }
};

class transfer_at_least
{
public:
    explicit transfer_at_least(size_t __sz) : __size(__sz) {}
    size_t operator()(const _VSTD::error_code& __ec, size_t __sz) const
                    { return ( !__ec || __sz >= __size ) ? 0 : __default_transfer_size; }
private:
    size_t __size;
};

class transfer_exactly
{
public:
    explicit transfer_exactly(size_t __sz) : __size(__sz) {}
    size_t operator()(const _VSTD::error_code& __ec, size_t __sz) const
        {
            return ( !__ec || __sz >= __size ) ? 0 
                : _VSTD::min(__size - __sz, static_cast<size_t>(__default_transfer_size));
        }
private:
    size_t __size;
};


// synchronous read operations:
template<class _SyncReadStream, class _MutableBufferSequence, class _CompletionCondition>
typename enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers, 
            _CompletionCondition __completion, _VSTD::error_code& __ec)
{
    __ec = _VSTD::error_code{};
    return 0;       // TODO
}

template<class _SyncReadStream, class _MutableBufferSequence, class _CompletionCondition>
typename enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers, 
                                                        _CompletionCondition __completion)
{
    _VSTD::error_code __ec;
    size_t __ret = read(__stream, __buffers, __completion, __ec);
    if (!__ec) throw _VSTD::system_error(__ec, "read(Mutable)");
    return __ret;
}

template<class _SyncReadStream, class _MutableBufferSequence>
typename enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers, _VSTD::error_code& __ec)
{ return read(__stream, __buffers, transfer_all(), __ec); }

template<class _SyncReadStream, class _MutableBufferSequence>
typename enable_if<is_mutable_buffer_sequence<_MutableBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, const _MutableBufferSequence& __buffers)
{ return read(__stream, __buffers, transfer_all()); }


template<class _SyncReadStream, class _DynamicBufferSequence, class _CompletionCondition>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, _DynamicBufferSequence&& __b, _CompletionCondition __completion, _VSTD::error_code& __ec)
{
    __ec = _VSTD::error_code{};
    return 0;       // TODO
}

template<class _SyncReadStream, class _DynamicBufferSequence, class _CompletionCondition>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, _DynamicBufferSequence&& __b, _CompletionCondition __completion)
{
    _VSTD::error_code __ec;
    size_t __ret = read(__stream, _VSTD::forward<_DynamicBufferSequence>(__b), __completion, __ec);
    if (!__ec) throw _VSTD::system_error(__ec, "read(Dynamic)");
    return __ret;
}

template<class _SyncReadStream, class _DynamicBufferSequence>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, _DynamicBufferSequence&& __b, _VSTD::error_code& __ec)
{ return read(__stream, _VSTD::forward(__b), transfer_all(), __ec); }

template<class _SyncReadStream, class _DynamicBufferSequence>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
read(_SyncReadStream& __stream, _DynamicBufferSequence&& __b)
{ return read(__stream, _VSTD::forward<_DynamicBufferSequence>(__b), transfer_all()); }

// asynchronous read operations:
// template<class AsyncReadStream, class MutableBufferSequence,
// class CompletionToken>
//   auto async_read(AsyncReadStream& stream,
//                const MutableBufferSequence& buffers,
//                CompletionToken&& token);
// template<class AsyncReadStream, class MutableBufferSequence,
// class CompletionCondition, class CompletionToken>
//   auto async_read(AsyncReadStream& stream,
//                const MutableBufferSequence& buffers,
//                CompletionCondition completion_condition,
//                CompletionToken&& token);
// template<class AsyncReadStream, class DynamicBufferSequence,
// class CompletionToken>
//   auto async_read(AsyncReadStream& stream,
//                DynamicBufferSequence&& b,
//                CompletionToken&& token);
// template<class AsyncReadStream, class DynamicBufferSequence,
// class CompletionCondition, class CompletionToken>
//   auto async_read(AsyncReadStream& stream,
//                DynamicBufferSequence&& b,
//                CompletionCondition completion_condition,
//                CompletionToken&& token);

// synchronous write operations:

template<class _SyncWriteStream, class _CompletionCondition>
size_t __write_buffer(_SyncWriteStream& __stream, const_buffer __buf,
                              _CompletionCondition __completion, _VSTD::error_code& __ec)
{
    __ec = _VSTD::error_code{};
    size_t __ret = 0;
//     while ( buffer_size(__buf) > 0 )
//     {
//     	ret += __stream.write_some(__buf, __ec);
//     	if (__ec) break;
//     	
//     }
    return __ret;
}


template<class _SyncWriteStream, class _ConstBufferSequence, class _CompletionCondition>
typename enable_if<is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, const _ConstBufferSequence& __buffers,
                              _CompletionCondition __completion, _VSTD::error_code& __ec)
{
    __ec = _VSTD::error_code{};
    size_t __ret = 0;
    for ( auto __iter = __buffers.begin(); !__ec && __Iiter != __buffers.end(); ++__iter )
    {
    	ret += __write_buffer(stream, *__iter, _completion, __ec);
    	if (__ec) break;
    }
    return __ret;
}

template<class _SyncWriteStream, class _ConstBufferSequence, class _CompletionCondition>
typename enable_if<is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, const _ConstBufferSequence& __buffers, _CompletionCondition __completion)
{
    _VSTD::error_code __ec;
    size_t __ret = write(__stream, __buffers, __completion, __ec);
   	if (__ec) throw system_error(__ec, "write(Const)");
    return __ret;
}

template<class _SyncWriteStream, class _ConstBufferSequence>
typename enable_if<is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, const _ConstBufferSequence& __buffers, error_code& __ec)
{ return write(__stream, __buffers, transfer_all(), __ec); }

template<class _SyncWriteStream, class _ConstBufferSequence>
typename enable_if<is_const_buffer_sequence<_ConstBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, const _ConstBufferSequence& __buffers)
{ return write(__stream, __buffers, transfer_all()); }


template<class _SyncWriteStream, class _DynamicBufferSequence, class _CompletionCondition>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, _DynamicBufferSequence&& __b,
                               _CompletionCondition __completion, _VSTD::error_code& __ec)
{
    __ec = _VSTD::error_code{};
    size_t __ret = 0;
    return __ret;
}

template<class _SyncWriteStream, class _DynamicBufferSequence, class _CompletionCondition>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, _DynamicBufferSequence&& __b, _CompletionCondition __completion)
{
    _VSTD::error_code __ec;
    size_t __ret = write(__stream, _VSTD::forward<_DynamicBufferSequence>(__b), __completion, __ec);
   	if (__ec) throw system_error(__ec, "write(Dynamic)");
    return __ret;
}

template<class _SyncWriteStream, class _DynamicBufferSequence>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, _DynamicBufferSequence&& __b, _VSTD::error_code& __ec)
{ return write(__stream, _VSTD::forward<_DynamicBufferSequence>(__b), transfer_all(), __ec); }

template<class _SyncWriteStream, class _DynamicBufferSequence>
typename enable_if<is_dynamic_buffer_sequence<_DynamicBufferSequence>::value, size_t>::type
write(_SyncWriteStream& __stream, _DynamicBufferSequence&& __b)
{ return write(__stream, _VSTD::forward<_DynamicBufferSequence>(__b), transfer_all()); }


// asynchronous write operations:
// 
//       template<class AsyncWriteStream, class ConstBufferSequence,
//         class CompletionToken>
//           auto async_write(AsyncWriteStream& stream,
//                            const ConstBufferSequence& buffers,
//                            CompletionToken&& token);
//       template<class AsyncWriteStream, class ConstBufferSequence,
//         class CompletionCondition, class CompletionToken>
//           auto async_write(AsyncWriteStream& stream,
//                            const ConstBufferSequence& buffers,
//                            CompletionCondition completion_condition,
//                            CompletionToken&& token);
//       template<class AsyncWriteStream, class DynamicBufferSequence,
//         class CompletionToken>
//           auto async_write(AsyncWriteStream& stream,
//                            DynamicBufferSequence&& b,
//                            CompletionToken&& token);
//       template<class AsyncWriteStream, class DynamicBufferSequence,
//         class CompletionCondition, class CompletionToken>
//           auto async_write(AsyncWriteStream& stream,
//                            DynamicBufferSequence&& b,
//                            CompletionCondition completion_condition,
//                            CompletionToken&& token);


_LIBCPP_END_NAMESPACE_NETWORK

#endif
