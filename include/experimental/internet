// -*- C++ -*-
//===---------------------------- internet --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//  Based on N4332
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_INTERNET
#define _LIBCPP_EXPERIMENTAL_INTERNET

/* 
    internet synopsis

namespace std {
  namespace experimental {
    inline namespace network_v1 {
      namespace ip {

        enum class resolver_errc {
          host_not_found = implementation defined, // EAI_NONAME
          host_not_found_try_again = implementation defined, // EAI_AGAIN
          service_not_found = implementation defined // EAI_SERVICE
        };

        const error_category& resolver_category() noexcept;

        error_code make_error_code(resolver_errc e) noexcept;
        error_condition make_error_condition(resolver_errc e) noexcept;

        struct v4_mapped_t {};
        constexpr v4_mapped_t v4_mapped;

        class address;
        class address_v4;
        class address_v6;

        class bad_address_cast;

        // address comparisons:
        bool operator==(const address&, const address&) noexcept;
        bool operator!=(const address&, const address&) noexcept;
        bool operator< (const address&, const address&) noexcept;
        bool operator> (const address&, const address&) noexcept;
        bool operator<=(const address&, const address&) noexcept;
        bool operator>=(const address&, const address&) noexcept;

        // address_v4 comparisons:
        bool operator==(const address_v4&, const address_v4&) noexcept;
        bool operator!=(const address_v4&, const address_v4&) noexcept;
        bool operator< (const address_v4&, const address_v4&) noexcept;
        bool operator> (const address_v4&, const address_v4&) noexcept;
        bool operator<=(const address_v4&, const address_v4&) noexcept;
        bool operator>=(const address_v4&, const address_v4&) noexcept;

        // address_v6 comparisons:
        bool operator==(const address_v6&, const address_v6&) noexcept;
        bool operator!=(const address_v6&, const address_v6&) noexcept;
        bool operator< (const address_v6&, const address_v6&) noexcept;
        bool operator> (const address_v6&, const address_v6&) noexcept;
        bool operator<=(const address_v6&, const address_v6&) noexcept;
        bool operator>=(const address_v6&, const address_v6&) noexcept;

        // address creation:
        address make_address(const char*);
        address make_address(const char*, error_code&) noexcept;
        address make_address(const string_view&);
        address make_address(const string_view&, error_code&) noexcept;

        // address_v4 creation:
        constexpr address_v4 make_address_v4(const address_v4::bytes_type&);
        constexpr address_v4 make_address_v4(unsigned long);
        constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&);
        address_v4 make_address_v4(const char*);
        address_v4 make_address_v4(const char*, error_code&) noexcept;
        address_v4 make_address_v4(const string_view&);
        address_v4 make_address_v4(const string_view&, error_code&) noexcept;

        // address_v6 creation:
        constexpr address_v6 make_address_v6(const address_v6::bytes_type&, unsigned long = 0);
        constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&) noexcept;
        address_v6 make_address_v6(const char*);
        address_v6 make_address_v6(const char*, error_code&) noexcept;
        address_v6 make_address_v6(const string_view&);
        address_v6 make_address_v6(const string_view&, error_code&) noexcept;

        // address I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address&);

        // address_v4 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address_v4&);

        // address_v6 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address_v6&);

        // address conversions:
        template<class T> constexpr T address_cast(const address&) noexcept(see below);
        template<class T> constexpr T address_cast(const address_v4&) noexcept(see below);
        template<class T> constexpr T address_cast(const address_v6&) noexcept(see below);

        class address_iterator_v4;
        class address_iterator_v6;

        class address_range_v4;
        class address_range_v6;

        class network_v4;
        class network_v6;

        // network_v4 comparisons:
        bool operator==(const network_v4&, const network_v4&) noexcept;
        bool operator!=(const network_v4&, const network_v4&) noexcept;

        // network_v6 comparisons:
        bool operator==(const network_v6&, const network_v6&) noexcept;
        bool operator!=(const network_v6&, const network_v6&) noexcept;

        // network_v4 creation:
        network_v4 make_network_v4(const address_v4&, unsigned short);
        network_v4 make_network_v4(const address_v4&, const address_v4&);
        network_v4 make_network_v4(const char*);
        network_v4 make_network_v4(const char*, error_code&) noexcept;
        network_v4 make_network_v4(const string_view&);
        network_v4 make_network_v4(const string_view&, error_code&) noexcept;

        // network_v6 creation:
        network_v6 make_network_v6(const address_v6&, unsigned short);
        network_v6 make_network_v6(const char*);
        network_v6 make_network_v6(const char*, error_code&) noexcept;
        network_v6 make_network_v6(const string_view&);
        network_v6 make_network_v6(const string_view&, error_code&) noexcept;

        // network_v4 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const network_v4&);

        // network_v6 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const network_v6&);

        template<class InternetProtocol>
          class basic_endpoint;

        // basic_endpoint comparisons:
        template<class InternetProtocol>
          bool operator==(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator!=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator< (const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator> (const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator<=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator>=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);

        // basic_endpoint I/O:
        template<class CharT, class Traits, class InternetProtocol>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&,
            const basic_endpoint<InternetProtocol>&);

        class resolver_query_base;

        template<class InternetProtocol>
          basic_resolver_query;

        template<class InternetProtocol>
          basic_resolver_entry;

        template<class InternetProtocol>
          basic_resolver_iterator;

        template<class InternetProtocol>
          class basic_resolver;

        string host_name();
        string host_name(error_code&);

        class tcp;

        // tcp comparisons:
        bool operator==(const tcp& a, const tcp& b);
        bool operator!=(const tcp& a, const tcp& b);

        class udp;

        // udp comparisons:
        bool operator==(const udp& a, const udp& b);
        bool operator!=(const udp& a, const udp& b);

        class v6_only;

        namespace unicast {

          class hops;

        } // namespace unicast

        namespace multicast {

          class join_group;

          class leave_group;

          class outbound_interface;

          class hops;

          class enable_loopback;

        } // namespace multicast
      } // namespace ip
    } // inline namespace network_v1
  } // namespace experimental

  template<> struct is_error_condition_enum<
    experimental::network_v1::ip::resolver_errc>
      : public true_type {};

  // hash support
  template<class T> struct hash;
  template<> struct hash<experimental::network_v1::ip::address>;
  template<> struct hash<experimental::network_v1::ip::address_v4>;
  template<> struct hash<experimental::network_v1::ip::address_v6>;

} // namespace std      

*/

#include <experimental/__net_config>
#include <system_error> // for error_code
#include <stdexcept>
#include <typeinfo>     // for std::bad_cast
#include <array>
#include <string>
#include <experimental/string_view>

_LIBCPP_BEGIN_NAMESPACE_NETWORK_IP

_VSTD_LFTS::string_view __make_sv (const char *__s) { return _VSTD_LFTS::string_view{__s, strlen(__s)}; }
char __to_hex(int __v) { return char(__v > 9 ? 'A' - 10 + __v : '0' + __v); }


class address;
class address_v4;
class address_v6;
class bad_address_cast;

struct v4_mapped_t {};
constexpr v4_mapped_t v4_mapped{};

template <class _Address>
class _Address_iterator;
typedef _Address_iterator<address_v4> address_iterator_v4;
typedef _Address_iterator<address_v6> address_iterator_v6;

template<class _Tp> constexpr _Tp address_cast(const address&   ) noexcept(_VSTD::is_same<_Tp, address>::value);
template<class _Tp> constexpr _Tp address_cast(const address_v4&) noexcept;
template<class _Tp> constexpr _Tp address_cast(const address_v6&) noexcept;


template <size_t _Sz>
struct __bytes_type : _VSTD::array<unsigned char, _Sz>
    {
        template<class... T> explicit constexpr __bytes_type(T... t)
            : _VSTD::array<unsigned char, _Sz>{{static_cast<unsigned char>(t)...}} {}
//         constexpr __bytes_type(const __bytes_type &__rhs)
//         { memcpy ( &this[0], &__rhs[0], sizeof(*this)); }
// 
//         constexpr __bytes_type& operator=(const __bytes_type &__rhs)
//         {
//             if ( this != &__rhs)
//                 memcpy ( &this[0], &__rhs[0], sizeof(*this));
//             return *this;
//         }
        constexpr bool operator==(const __bytes_type &__rhs) const
        {
        for ( size_t __i = 0; __i < _Sz; ++__i )
            if ((*this)[__i] != __rhs[__i]) return false;
        return true;
        }
        constexpr bool operator<(const __bytes_type &__rhs) const
        {
        for ( size_t __i = 0; __i < _Sz; ++__i )
            if ((*this)[__i] < __rhs[__i]) return true;
        return false;
        }
    };

class _LIBCPP_EXCEPTION_ABI bad_address_cast : public std::bad_cast
{
public:
//  virtual const char* what() const noexcept;
};

class address_v4
    {
public:
    friend address_iterator_v4;
    typedef __bytes_type<4> bytes_type;

    constexpr address_v4() noexcept : __bytes(0,0,0,0) {}
    constexpr address_v4(const address_v4& __rhs) noexcept : __bytes(__rhs.__bytes) {}
    constexpr address_v4(const bytes_type& __b) : __bytes(__b)
    {
#if UCHAR_MAX > 0xFF
    for ( const auto __c : __b )
        if ( __c > 0xFFF ) throw std::out_of_range{"Octet too big in address_v4::address_v4"};
#endif
    }

    explicit constexpr address_v4(unsigned long __v)
        : __bytes {(__v >> 24) & 0xFF, (__v >> 16) & 0xFF, (__v >> 8) & 0xFF, __v & 0xFF}
    {
#if ULONG_MAX > 0xFFFFFFFF
    if ( __v > 0xFFFFFFFF ) throw std::out_of_range{"Long too big in address_v4::address_v4"};
#endif
    }

    address_v4& operator=(const address_v4& __rhs) noexcept
    {
        __bytes = __rhs.__bytes;
        return *this;
    }       

    constexpr bool is_unspecified() const noexcept { return to_ulong() == 0; }
    constexpr bool is_loopback()    const noexcept { return (to_ulong() & 0xFF000000) == 0x7F000000; }
    constexpr bool is_class_a()     const noexcept { return (to_ulong() & 0x80000000) == 0; }
    constexpr bool is_class_b()     const noexcept { return (to_ulong() & 0xC0000000) == 0x80000000; }
    constexpr bool is_class_c()     const noexcept { return (to_ulong() & 0xE0000000) == 0xC0000000; }
    constexpr bool is_multicast()   const noexcept { return (to_ulong() & 0xF0000000) == 0xE0000000; }
    constexpr bytes_type to_bytes() const noexcept { return __bytes; }
    constexpr unsigned long to_ulong() const noexcept {
        unsigned long __val = (((unsigned long)__bytes[0]) << 24) | 
                              (((unsigned long)__bytes[1]) << 16) | 
                              (((unsigned long)__bytes[2]) <<  8) |
                                               __bytes[3];
        return __val;
    }
    
    _VSTD::string to_string() const;

    static constexpr address_v4 any()       noexcept { return address_v4(); }
    static constexpr address_v4 loopback()  noexcept { return address_v4(0x7F000001); }
    static constexpr address_v4 broadcast() noexcept { return address_v4(0xFFFFFFFF); }
    static constexpr address_v4 broadcast( 
        const address_v4& __addr,
        const address_v4& __mask) noexcept { return address_v4(__addr.to_ulong() | ~__mask.to_ulong()); }

   private:
        bytes_type __bytes;
    };

    _VSTD::string address_v4::to_string() const // TODO: temporary implementation
    {
        _VSTD::string ret(16, '0');
        auto it = ret.begin();
        for ( const auto c : __bytes ) {
            if ( c >= 100 )
                *it++ += ( c / 100 ) % 10;
            if ( c >= 10 )
                *it++  += ( c / 10 ) % 10;
            *it++  += c % 10;
            *it++  = '.';
            }
        ret.erase ( --it, ret.end());
        return ret;
    }
    
constexpr bool operator==(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return __lhs.to_ulong() == __rhs.to_ulong(); }
constexpr bool operator!=(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return !(__lhs == __rhs); }
constexpr bool operator< (const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return __lhs.to_ulong() < __rhs.to_ulong(); }
constexpr bool operator> (const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return __rhs < __lhs; }
constexpr bool operator<=(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return !(__rhs < __lhs); }
constexpr bool operator>=(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return !(__lhs < __rhs); }


template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
    basic_ostream<CharT, Traits>& os, const address_v4& __addr)
{
    for ( char c : __addr.to_string())
        os << os.widen(c);
    return os;
}

class address_v6
    {
public:
    typedef __bytes_type<16> bytes_type;
    friend address_iterator_v6;
    
    constexpr address_v6() noexcept
        : __bytes(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), __scope_id(0) {}
    constexpr address_v6(const address_v6& __rhs) noexcept
        : __bytes(__rhs.__bytes), __scope_id(__rhs.__scope_id)  {}
    constexpr address_v6(const bytes_type& __b, unsigned long scope = 0)
        : __bytes(__b), __scope_id(scope)
    {
#if UCHAR_MAX > 0xFF
    for ( const auto __c : __b )
        if ( __c > 0xFFF ) throw std::out_of_range{"Octet too big in address_v6::address_v6"};
#endif
    }

    address_v6& operator=(const address_v6& __rhs) noexcept
    {
        __bytes    = __rhs.__bytes;
        __scope_id = __rhs.__scope_id;
        return *this;
    }

    void scope_id(unsigned long __id) noexcept        { __scope_id = __id; }
    constexpr unsigned long scope_id() const noexcept { return __scope_id; }

    constexpr bool is_unspecified() const noexcept
    {
//     for ( auto const c : __bytes )
//         if ( c != 0 ) return false;
    for ( size_t __i = 0; __i < 16; ++__i )
        if ( __bytes[__i] != 0 ) return false;
    return true;
    }
  
    constexpr bool is_loopback() const noexcept
    {
    for ( size_t i = 0; i < 15; ++i )
        if ( __bytes[i] != 0 ) return false;
    return __bytes[15] == 1;
    }

    constexpr bool is_multicast()  const noexcept { return __bytes[0] == 0xFF; }
    constexpr bool is_link_local() const noexcept { return __bytes[0] == 0xFE && (__bytes[1] & 0xC0) == 0x80; }
    constexpr bool is_site_local() const noexcept { return __bytes[0] == 0xFE && (__bytes[1] & 0xC0) == 0xC0; }
    constexpr bool is_v4_mapped()  const noexcept
    { 
    for ( size_t i = 0; i < 10; ++i )
        if ( __bytes[i] != 0 ) return false;
    return __bytes[10] == 0xFF && __bytes[11] == 0xFF;
    }

    constexpr bool is_multicast_node_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x01; }
    constexpr bool is_multicast_link_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x02; }
    constexpr bool is_multicast_site_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x05; }
    constexpr bool is_multicast_org_local()  const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x08; }
    constexpr bool is_multicast_global()     const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x0E; }

    constexpr bytes_type to_bytes() const noexcept { return __bytes; }
    _VSTD::string to_string() const;  // !!! TODO

  // static members:
  static constexpr address_v6 any() noexcept { return address_v6(); }
  static constexpr address_v6 loopback() noexcept
  { return address_v6(address_v6::bytes_type{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}); }
  
private:
    bytes_type __bytes;
    unsigned long __scope_id;
    };

_VSTD::string address_v6::to_string() const // TODO: temporary implementation
{
	_VSTD::string ret(48, '0');
	auto it = ret.begin();
	for ( const auto c : __bytes ) {
		*it++ += __to_hex((c >> 4) & 0x0F);
		*it++ += __to_hex((c     ) & 0x0F);
		*it++  = ':';
		}
	ret.erase ( --it, ret.end());
	return ret;
}

constexpr address_v4 make_address_v4(const address_v4::bytes_type& __b)
{ return address_v4(__b); }

constexpr address_v4 make_address_v4(unsigned long __v)
{ return address_v4(__v); }

constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6& __a)
{
	if (!__a.is_v4_mapped()) throw bad_address_cast{};
	const address_v6::bytes_type __6bytes{__a.to_bytes()};
	address_v4::bytes_type __4bytes{__6bytes[12], __6bytes[13], __6bytes[14], __6bytes[15]};
	return address_v4(__4bytes);
}

address_v4 make_address_v4(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept
{
    __ec.assign(EOPNOTSUPP, _VSTD::system_category());
    return address_v4(); // !!! TODO
}

address_v4 make_address_v4(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address_v4 addr = make_address_v4(__sv, __ec);
    if (__ec) throw __ec;
    return addr;
}

address_v4 make_address_v4(const char* __s)
{ return make_address_v4(__make_sv(__s)); }

address_v4 make_address_v4(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address_v4(__make_sv(__s), __ec); }

constexpr address_v6 make_address_v6(const address_v6::bytes_type& __bytes, unsigned long __id = 0)
{ return address_v6(__bytes, __id); }

constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4& __a) noexcept
{
	const address_v4::bytes_type __4bytes{__a.to_bytes()};
	address_v6::bytes_type __6bytes{ 0, 0, 0, 0, 0, 0, 0, 0,
				  0, 0, 0xFF, 0xFF, __4bytes[0], __4bytes[1], __4bytes[2], __4bytes[3] };
  return address_v6(__6bytes);
}

address_v6 make_address_v6(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept
{
    __ec.assign(EOPNOTSUPP, _VSTD::system_category());
    return address_v6(); // !!! TODO
}

address_v6 make_address_v6(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address_v6 addr = make_address_v6(__sv, __ec);
    if (__ec) throw __ec;
    return addr;
}   

address_v6 make_address_v6(const char* __s)
{ return make_address_v6(__make_sv(__s)); }

address_v6 make_address_v6(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address_v6(__make_sv(__s), __ec); }


constexpr bool operator==(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return (__lhs.scope_id() == __rhs.scope_id()) && (__lhs.to_bytes() == __rhs.to_bytes()); }
constexpr bool operator!=(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return !(__lhs == __rhs); }
constexpr bool operator< (const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return __lhs.to_bytes() < __rhs.to_bytes() || (!(__rhs.to_bytes() < __lhs.to_bytes()) && __lhs.scope_id() < __rhs.scope_id()); }
constexpr bool operator> (const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return __rhs < __lhs; }
constexpr bool operator<=(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return !(__rhs < __lhs); }
constexpr bool operator>=(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return !(__lhs < __rhs); }

template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
    basic_ostream<CharT, Traits>& os, const address_v6& __addr)
{
    for ( char c : __addr.to_string())
        os << os.widen(c);
    return os;
}

class address
{
private:
    enum class _Address { __ip_none, __ipv4, __ipv6 };
    _Address __atype;
    address_v4 __v4;
    address_v6 __v6;

public:
    constexpr address() noexcept : __atype(_Address::__ip_none), __v4(), __v6() {}
    constexpr address(const address& __rhs) noexcept :
        __atype(__rhs.__atype), __v4(__rhs.__v4), __v6(__rhs.__v6) {}
    
//  template<class _Tp>
//  constexpr address(const _Tp& __t,
//      typename enable_if<
//          !_VSTD::is_same<_Tp, address>::value && 
//           _VSTD::is_same<address &, decltype(address_cast<address>(_Tp()))>::value>::type* = 0)
//       noexcept(address_cast<address>(_Tp())) : address(address_cast<address>(__t)) {}

    explicit constexpr address(const address_v4 &__rhs) noexcept :
        __atype(_Address::__ipv4), __v4(__rhs), __v6() {}
    explicit constexpr address(const address_v6 &__rhs) noexcept :
        __atype(_Address::__ipv6), __v4(), __v6(__rhs) {}

    address& operator=(const address& __rhs) noexcept
    {
        __atype = __rhs.__atype;
        __v4 = __rhs.__v4;
        __v6 = __rhs.__v6;
        return * this;
    }

    constexpr bool is_unspecified() const noexcept
    {
        if (is_v4()) return __v4.is_unspecified();
        if (is_v6()) return __v6.is_unspecified();
        return false;
    }
    
    constexpr bool is_loopback() const noexcept
    {
        if (is_v4()) return __v4.is_loopback();
        if (is_v6()) return __v6.is_loopback();
        return false;
    }

    constexpr bool is_multicast() const noexcept
    {
        if (is_v4()) return __v4.is_multicast();
        if (is_v6()) return __v6.is_multicast();
        return false;
    }

    constexpr bool is_v4() const noexcept { return __atype == _Address::__ipv4; }
    constexpr bool is_v6() const noexcept { return __atype == _Address::__ipv6; }

    _VSTD::string to_string() const
    {
        if (is_v4()) return __v4.to_string();
        if (is_v6()) return __v6.to_string();
        throw bad_address_cast{};
    }

    constexpr bool __equal(const address& __rhs) const
    {
//	They're the same type
    if (__atype == _Address::__ip_none && __rhs.__atype == _Address::__ip_none) return true;
    if (is_v4() && __rhs.is_v4()) return __v4 == __rhs.__v4;
    if (is_v6() && __rhs.is_v6()) return __v6 == __rhs.__v6;

//	One of them is empty
    if (__atype == _Address::__ip_none && __rhs.is_v4()) return address_v4() == __rhs.__v4;
    if (is_v4() && __rhs.__atype == _Address::__ip_none) return __v4 == address_v4();
    if (__atype == _Address::__ip_none && __rhs.is_v6()) return address_v6() == __rhs.__v6;
    if (is_v6() && __rhs.__atype == _Address::__ip_none) return __v6 == address_v6();

	return is_v4()
		? make_address_v6(v4_mapped, __v4) == __rhs.__v6
		: __v6 == make_address_v6(v4_mapped, __rhs.__v4);
    }

    constexpr bool __less (const address& __rhs) const { return true; } // !!! TODO
    constexpr address_v4 __get_v4 () const noexcept { return __v4; }
    constexpr address_v6 __get_v6 () const noexcept { return __v6; }
    };
    

// address comparisons:
constexpr bool operator==(const address& __lhs, const address& __rhs) noexcept
{ return __lhs.__equal(__rhs); }
constexpr bool operator!=(const address& __lhs, const address& __rhs) noexcept
{ return !(__lhs == __rhs); }
constexpr bool operator< (const address& __lhs, const address& __rhs) noexcept
{ return __lhs.__less(__rhs); }
constexpr bool operator> (const address& __lhs, const address& __rhs) noexcept
{ return __rhs < __lhs; }
constexpr bool operator<=(const address& __lhs, const address& __rhs) noexcept
{ return !(__rhs < __lhs); }
constexpr bool operator>=(const address& __lhs, const address& __rhs) noexcept
{ return !(__lhs < __rhs); }

// address creation:
address make_address(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept
{
    address_v6 __v6 = make_address_v6(__sv, __ec);
    if (!__ec)
     return address(__v6);
    address_v4 __v4 = make_address_v4(__sv, __ec);
    return !__ec ? address(__v4) : address ();
}

address make_address(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address __a = make_address(__sv, __ec);
    if (__ec) throw __ec;
    return __a;
}

address make_address(const char* __s) { return make_address(__make_sv(__s)); }
address make_address(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address(__make_sv(__s), __ec); }


// address I/O:
template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& __os, const address& __a)
{
    for ( const char __c : __a.to_string())
        __os << __os.widen(__c);
    return __os;
}

// template <class _Tp, class _Head, class... _Tail>
// struct __contains0 {
//  static const bool value = __contains0<_Tp, _Head>::value
//                         || __contains0<_Tp, _Tail...>::value;
// };
// 
// template <class _Tp, class _Head>
// struct __contains0<_Tp, _Head> {
//  static const bool value = std::is_same<_Head, _Tp>::value;
// };
// 
// template <class _Tp, class... _TypeList>
// struct __contains : public _VSTD::integral_constant<bool, __contains0<_Tp, _TypeList...>::value> {};
// 
// template <class _Tp>
// struct __is_address : public __contains<_Tp, address, address_v4, address_v6> {};


// template<class _Tp> constexpr _Tp address_cast(const address& __a)
template<> constexpr address    address_cast(const address&    __a) noexcept { return __a; }
template<> constexpr address_v4 address_cast(const address& __a) noexcept(false)
{
    if (!__a.is_v4()) throw bad_address_cast{};
    return __a.__get_v4();
}

template<> constexpr address_v6 address_cast(const address& __a) noexcept(false)
{
    if (!__a.is_v6()) throw bad_address_cast{};
    return __a.__get_v6();
}

// template<class _Tp> constexpr _Tp address_cast(const address_v4&) noexcept;
template<> constexpr address    address_cast(const address_v4& __a) noexcept { return address(__a); }
template<> constexpr address_v4 address_cast(const address_v4& __a) noexcept { return __a; }
template<> constexpr address_v6 address_cast(const address_v4& __a) noexcept = delete;

// template<class _Tp> constexpr _Tp address_cast(const address_v6&) noexcept;
template<> constexpr address    address_cast(const address_v6& __a) noexcept { return address(__a); }
template<> constexpr address_v4 address_cast(const address_v6& __a) noexcept = delete;
template<> constexpr address_v6 address_cast(const address_v6& __a) noexcept { return __a; }

template <class _Address>
class _Address_iterator
{
public:
    typedef _Address                  value_type;
    typedef ptrdiff_t                 difference_type;
    typedef const _Address*           pointer;
    typedef const _Address&           reference;
    typedef _VSTD::input_iterator_tag iterator_category;

    _Address_iterator() noexcept : __address() {}
    _Address_iterator(const _Address& __a) noexcept : __address(__a) {}

    reference operator*()  const noexcept { return __address; }
    pointer   operator->() const noexcept { return &__address; }

    _Address_iterator& operator++() noexcept
    {
        for (auto it = __address.__bytes.rbegin(); it != __address.__bytes.rend(); ++it) {
            if ( *it < 255 ) {
                ++*it;
                break;
                }
            *it = 0;
            }
        return *this;
    }

    _Address_iterator operator++(int) noexcept
    {
        _Address_iterator __prev = *this;
        ++*this;
        return __prev;
    }

    _Address_iterator& operator--() noexcept {
        for (auto it = __address.__bytes.rbegin(); it != __address.__bytes.rend(); ++it) {
            if ( *it > 0 ) {
                --*it;
                break;
                }
            *it = 255;
        }
        return *this;
    }
    
    _Address_iterator  operator--(int) noexcept
    {
        _Address_iterator __prev = *this;
        --*this;
        return __prev;
    }

    bool operator==(const _Address_iterator & __rhs) const noexcept
    { return __address == __rhs.__address; }
    bool operator!=(const _Address_iterator & __rhs) const noexcept
    { return !(__address == __rhs.__address); }

private:
    _Address __address;
};

class address_range_v4
{
public:
    typedef address_v4          address_type;
    typedef address_iterator_v4 iterator;

    // constructors:
    address_range_v4() noexcept : __b(), __e() {}
    address_range_v4(const address_type& __f, const address_type& __l) noexcept :
        __b(__f), __e(__l) {}

    iterator begin() const noexcept { return __b; }
    iterator end() const noexcept   { return __e; }
    bool empty() const noexcept     { return __b == __e; }

    size_t size() const noexcept { return __e->to_ulong() - __b->to_ulong(); }
    iterator find(const address_type& __a) const noexcept
    { return (*__b <= __a && __a < *__e) ? iterator(__a) : __e; }
        
private:
    iterator __b;
    iterator __e;
};

class address_range_v6
{
public:
    typedef address_v6          address_type;
    typedef address_iterator_v6 iterator;

    // constructors:
    address_range_v6() noexcept : __b(), __e() {}
    address_range_v6(const address_type& __f, const address_type& __l) noexcept :
        __b(__f), __e(__l) {}

    iterator begin() const noexcept { return __b; }
    iterator end() const noexcept   { return __e; }
    bool empty() const noexcept     { return __b == __e; }

    iterator find(const address_type& __a) const noexcept
    { return (*__b <= __a && __a < *__e) ? iterator(__a) : __e; }
        
private:
    iterator __b;
    iterator __e;
};


_LIBCPP_END_NAMESPACE_NETWORK_IP

#endif
