// -*- C++ -*-
//===---------------------------- internet --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//  Based on N4332
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_INTERNET
#define _LIBCPP_EXPERIMENTAL_INTERNET

/* 
    internet synopsis

namespace std {
  namespace experimental {
    inline namespace network_v1 {
      namespace ip {

        enum class resolver_errc {
          host_not_found = implementation defined, // EAI_NONAME
          host_not_found_try_again = implementation defined, // EAI_AGAIN
          service_not_found = implementation defined // EAI_SERVICE
        };

        const error_category& resolver_category() noexcept;

        error_code make_error_code(resolver_errc e) noexcept;
        error_condition make_error_condition(resolver_errc e) noexcept;

        struct v4_mapped_t {};
        constexpr v4_mapped_t v4_mapped;

        class address;
        class address_v4;
        class address_v6;

        class bad_address_cast;

        // address comparisons:
        bool operator==(const address&, const address&) noexcept;
        bool operator!=(const address&, const address&) noexcept;
        bool operator< (const address&, const address&) noexcept;
        bool operator> (const address&, const address&) noexcept;
        bool operator<=(const address&, const address&) noexcept;
        bool operator>=(const address&, const address&) noexcept;

        // address_v4 comparisons:
        bool operator==(const address_v4&, const address_v4&) noexcept;
        bool operator!=(const address_v4&, const address_v4&) noexcept;
        bool operator< (const address_v4&, const address_v4&) noexcept;
        bool operator> (const address_v4&, const address_v4&) noexcept;
        bool operator<=(const address_v4&, const address_v4&) noexcept;
        bool operator>=(const address_v4&, const address_v4&) noexcept;

        // address_v6 comparisons:
        bool operator==(const address_v6&, const address_v6&) noexcept;
        bool operator!=(const address_v6&, const address_v6&) noexcept;
        bool operator< (const address_v6&, const address_v6&) noexcept;
        bool operator> (const address_v6&, const address_v6&) noexcept;
        bool operator<=(const address_v6&, const address_v6&) noexcept;
        bool operator>=(const address_v6&, const address_v6&) noexcept;

        // address creation:
        address make_address(const char*);
        address make_address(const char*, error_code&) noexcept;
        address make_address(const string_view&);
        address make_address(const string_view&, error_code&) noexcept;

        // address_v4 creation:
        constexpr address_v4 make_address_v4(const address_v4::bytes_type&);
        constexpr address_v4 make_address_v4(unsigned long);
        constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&);
        address_v4 make_address_v4(const char*);
        address_v4 make_address_v4(const char*, error_code&) noexcept;
        address_v4 make_address_v4(const string_view&);
        address_v4 make_address_v4(const string_view&, error_code&) noexcept;

        // address_v6 creation:
        constexpr address_v6 make_address_v6(const address_v6::bytes_type&, unsigned long = 0);
        constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&) noexcept;
        address_v6 make_address_v6(const char*);
        address_v6 make_address_v6(const char*, error_code&) noexcept;
        address_v6 make_address_v6(const string_view&);
        address_v6 make_address_v6(const string_view&, error_code&) noexcept;

        // address I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address&);

        // address_v4 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address_v4&);

        // address_v6 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address_v6&);

        // address conversions:
        template<class T> constexpr T address_cast(const address&) noexcept(see below);
        template<class T> constexpr T address_cast(const address_v4&) noexcept(see below);
        template<class T> constexpr T address_cast(const address_v6&) noexcept(see below);

        class address_iterator_v4;
        class address_iterator_v6;

        class address_range_v4;
        class address_range_v6;

        class network_v4;
        class network_v6;

        // network_v4 comparisons:
        bool operator==(const network_v4&, const network_v4&) noexcept;
        bool operator!=(const network_v4&, const network_v4&) noexcept;

        // network_v6 comparisons:
        bool operator==(const network_v6&, const network_v6&) noexcept;
        bool operator!=(const network_v6&, const network_v6&) noexcept;

        // network_v4 creation:
        network_v4 make_network_v4(const address_v4&, unsigned short);
        network_v4 make_network_v4(const address_v4&, const address_v4&);
        network_v4 make_network_v4(const char*);
        network_v4 make_network_v4(const char*, error_code&) noexcept;
        network_v4 make_network_v4(const string_view&);
        network_v4 make_network_v4(const string_view&, error_code&) noexcept;

        // network_v6 creation:
        network_v6 make_network_v6(const address_v6&, unsigned short);
        network_v6 make_network_v6(const char*);
        network_v6 make_network_v6(const char*, error_code&) noexcept;
        network_v6 make_network_v6(const string_view&);
        network_v6 make_network_v6(const string_view&, error_code&) noexcept;

        // network_v4 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const network_v4&);

        // network_v6 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const network_v6&);

        template<class InternetProtocol>
          class basic_endpoint;

        // basic_endpoint comparisons:
        template<class InternetProtocol>
          bool operator==(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator!=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator< (const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator> (const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator<=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator>=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);

        // basic_endpoint I/O:
        template<class CharT, class Traits, class InternetProtocol>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&,
            const basic_endpoint<InternetProtocol>&);

        class resolver_query_base;

        template<class InternetProtocol>
          basic_resolver_query;

        template<class InternetProtocol>
          basic_resolver_entry;

        template<class InternetProtocol>
          basic_resolver_iterator;

        template<class InternetProtocol>
          class basic_resolver;

        string host_name();
        string host_name(error_code&);

        class tcp;

        // tcp comparisons:
        bool operator==(const tcp& a, const tcp& b);
        bool operator!=(const tcp& a, const tcp& b);

        class udp;

        // udp comparisons:
        bool operator==(const udp& a, const udp& b);
        bool operator!=(const udp& a, const udp& b);

        class v6_only;

        namespace unicast {

          class hops;

        } // namespace unicast

        namespace multicast {

          class join_group;

          class leave_group;

          class outbound_interface;

          class hops;

          class enable_loopback;

        } // namespace multicast
      } // namespace ip
    } // inline namespace network_v1
  } // namespace experimental

  template<> struct is_error_condition_enum<
    experimental::network_v1::ip::resolver_errc>
      : public true_type {};

  // hash support
  template<class T> struct hash;
  template<> struct hash<experimental::network_v1::ip::address>;
  template<> struct hash<experimental::network_v1::ip::address_v4>;
  template<> struct hash<experimental::network_v1::ip::address_v6>;

} // namespace std      

*/

#include <experimental/__net_config>
#include <system_error> // for error_code
#include <array>
#include <string>
#include <stdexcept>
#include <experimental/string_view>

_LIBCPP_BEGIN_NAMESPACE_NETWORK_IP

_VSTD_LFTS::string_view __make_sv (const char *__s) { return _VSTD_LFTS::string_view{__s, strlen(__s)}; }

template <size_t sz>
struct __bytes_type : _VSTD::array<unsigned char, sz>
    {
        template<class... T> explicit constexpr __bytes_type(T... t)
            : array<unsigned char, sz>{{static_cast<unsigned char>(t)...}} {}
//         constexpr __bytes_type(const __bytes_type &__rhs)
//         { memcpy ( &this[0], &__rhs[0], sizeof(*this)); }
// 
//         constexpr __bytes_type& operator=(const __bytes_type &__rhs)
//         {
//             if ( this != &__rhs)
//                 memcpy ( &this[0], &__rhs[0], sizeof(*this));
//             return *this;
//         }
    };

class address_v4
    {
public:
    typedef __bytes_type<4> bytes_type;

    constexpr address_v4() noexcept : __bytes(0,0,0,0) {}
    constexpr address_v4(const address_v4& __rhs) noexcept : __bytes(__rhs.__bytes) {}
    constexpr address_v4(const bytes_type& __b) : __bytes(__b)
    {
#if UCHAR_MAX > 0xFF
    for ( const auto __c : __b )
        if ( __c > 0xFFF ) throw std::out_of_range{"Octet too big in address_v4::address_v4"};
#endif
    }

    explicit constexpr address_v4(unsigned long __v)
        : __bytes {(__v >> 24) & 0xFF, (__v >> 16) & 0xFF, (__v >> 8) & 0xFF, __v & 0xFF}
    {
#if ULONG_MAX > 0xFFFFFFFF
    if ( __v > 0xFFFFFFFF ) throw std::out_of_range{"Long too big in address_v4::address_v4"};
#endif
    }

    address_v4& operator=(const address_v4& __rhs) noexcept
    {
        __bytes = __rhs.__bytes;
        return *this;
    }       

    constexpr bool is_unspecified() const noexcept { return to_ulong() == 0; }
    constexpr bool is_loopback()    const noexcept { return (to_ulong() & 0xFF000000) == 0x7F000000; }
    constexpr bool is_class_a()     const noexcept { return (to_ulong() & 0x80000000) == 0; }
    constexpr bool is_class_b()     const noexcept { return (to_ulong() & 0xC0000000) == 0x80000000; }
    constexpr bool is_class_c()     const noexcept { return (to_ulong() & 0xE0000000) == 0xC0000000; }
    constexpr bool is_multicast()   const noexcept { return (to_ulong() & 0xF0000000) == 0xE0000000; }
    constexpr bytes_type to_bytes() const noexcept { return __bytes; }
    constexpr unsigned long to_ulong() const noexcept {
        unsigned long __val = (((unsigned long)__bytes[0]) << 24) | 
                              (((unsigned long)__bytes[1]) << 16) | 
                              (((unsigned long)__bytes[2]) <<  8) |
                                               __bytes[3];
        return __val;
    }
    
    _VSTD::string to_string() const;

    static constexpr address_v4 any()       noexcept { return address_v4(); }
    static constexpr address_v4 loopback()  noexcept { return address_v4(0x7F000001); }
    static constexpr address_v4 broadcast() noexcept { return address_v4(0xFFFFFFFF); }
    static constexpr address_v4 broadcast( 
        const address_v4& __addr,
        const address_v4& __mask) noexcept { return address_v4(__addr.to_ulong() | ~__mask.to_ulong()); }

   private:
        bytes_type __bytes;
    };

    _VSTD::string address_v4::to_string() const // TODO: temporary implementation
    {
        _VSTD::string ret(16, '0');
        auto it = ret.begin();
        for ( const auto c : __bytes ) {
            if ( c > 100 )
                *it++ += ( c / 100 ) % 10;
            if ( c > 10 )
                *it++  += ( c / 10 ) % 10;
            *it++  += c % 10;
            *it++  = '.';
            }
        ret.erase ( --it, ret.end());
        return ret;
    }
    
constexpr bool operator==(const address_v4& __x, const address_v4& __y) noexcept
{ return __x.to_ulong() == __y.to_ulong(); }

constexpr bool operator!=(const address_v4& __x, const address_v4& __y) noexcept
{ return !(__x == __y); }

constexpr bool operator< (const address_v4& __x, const address_v4& __y) noexcept
{ return __x.to_ulong() < __y.to_ulong(); }

constexpr bool operator> (const address_v4& __x, const address_v4& __y) noexcept
{ return __y < __x; }

constexpr bool operator<=(const address_v4& __x, const address_v4& __y) noexcept
{ return !(__y < __x); }

constexpr bool operator>=(const address_v4& __x, const address_v4& __y) noexcept
{ return !(__x < __y); }

constexpr address_v4 make_address_v4(const address_v4::bytes_type& __b)
{ return address_v4(__b); }

constexpr address_v4 make_address_v4(unsigned long __v)
{ return address_v4(__v); }

//    constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6& a); // !!! TODO

address_v4 make_address_v4(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept
{
    __ec.assign(EOPNOTSUPP, _VSTD::system_category());
    return address_v4(); // !!! TODO
}

address_v4 make_address_v4(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address_v4 addr = make_address_v4(__sv, __ec);
    if ( __ec) throw __ec;
    return addr;
}

address_v4 make_address_v4(const char* __s)
{ return make_address_v4(__make_sv(__s)); }

address_v4 make_address_v4(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address_v4(__make_sv(__s), __ec); }

template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
    basic_ostream<CharT, Traits>& os, const address_v4& __addr)
{
    for ( char c : __addr.to_string())
        os << os.widen(c);
    return os;
}

class address_v6
    {
public:
    typedef __bytes_type<16> bytes_type;

    constexpr address_v6() noexcept
        : __bytes(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), __scope_id(0) {}
    constexpr address_v6(const address_v6& __rhs) noexcept
        : __bytes(__rhs.__bytes), __scope_id(__rhs.__scope_id)  {}
    constexpr address_v6(const bytes_type& __b, unsigned long scope = 0)
        : __bytes(__b), __scope_id(scope)
    {
#if UCHAR_MAX > 0xFF
    for ( const auto __c : __b )
        if ( __c > 0xFFF ) throw std::out_of_range{"Octet too big in address_v6::address_v6"};
#endif
    }

    address_v6& operator=(const address_v6& __rhs) noexcept
    {
        __bytes    = __rhs.__bytes;
        __scope_id = __rhs.__scope_id;
        return *this;
    }

    void scope_id(unsigned long __id) noexcept        { __scope_id = __id; }
    constexpr unsigned long scope_id() const noexcept { return __scope_id; }

    constexpr bool is_unspecified() const noexcept
    {
    for ( auto const c : __bytes )
        if ( c != 0 ) return false;
    return true;
    }
  
    constexpr bool is_loopback() const noexcept
    {
    for ( size_t i = 0; i < 15; ++i )
        if ( __bytes[i] != 0 ) return false;
    return __bytes[15] == 1;
    }

    constexpr bool is_multicast()  const noexcept { return __bytes[0] == 0xFF; }
    constexpr bool is_link_local() const noexcept { return __bytes[0] == 0xFE && (__bytes[1] & 0xC0) == 0x80; }
    constexpr bool is_site_local() const noexcept { return __bytes[0] == 0xFE && (__bytes[1] & 0xC0) == 0xC0; }
    constexpr bool is_v4_mapped()  const noexcept
    { 
    for ( size_t i = 0; i < 10; ++i )
        if ( __bytes[i] != 0 ) return false;
    return __bytes[10] == 0xFF && __bytes[11] == 0xFF;
    }

    constexpr bool is_multicast_node_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x01; }
    constexpr bool is_multicast_link_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x02; }
    constexpr bool is_multicast_site_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x05; }
    constexpr bool is_multicast_org_local()  const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x08; }
    constexpr bool is_multicast_global()     const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x0E; }

    constexpr bytes_type to_bytes() const noexcept { return __bytes; }
    string to_string() const;  // !!! TODO

  // static members:
  static constexpr address_v6 any() noexcept { return address_v6(); }
  static constexpr address_v6 loopback() noexcept
  { return address_v6(address_v6::bytes_type{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}); }
  
private:
    bytes_type __bytes;
    unsigned long __scope_id;
    };

//         constexpr address_v6 make_address_v6(const address_v6::bytes_type& bytes,
//                                              unsigned long scope_id = 0);
//         constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4& a) noexcept;

address_v6 make_address_v6(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept
{
    __ec.assign(EOPNOTSUPP, _VSTD::system_category());
    return address_v6(); // !!! TODO
}

address_v6 make_address_v6(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address_v6 addr = make_address_v6(__sv, __ec);
    if ( __ec) throw __ec;
    return addr;
}   

address_v6 make_address_v6(const char* __s)
{ return make_address_v6(__make_sv(__s)); }

address_v6 make_address_v6(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address_v6(__make_sv(__s), __ec); }


bool operator==(const address_v6& __x, const address_v6& __y) noexcept
{ return (__x.scope_id() == __y.scope_id()) && (__x.to_bytes() == __y.to_bytes()); }

bool operator!=(const address_v6& __x, const address_v6& __y) noexcept
{ return !(__x == __y); }

bool operator< (const address_v6& __x, const address_v6& __y) noexcept
{ return __x.to_bytes() < __y.to_bytes() || (!(__y.to_bytes() < __x.to_bytes()) && __x.scope_id() < __y.scope_id()); }

bool operator> (const address_v6& __x, const address_v6& __y) noexcept
{ return __y < __x; }

bool operator<=(const address_v6& __x, const address_v6& __y) noexcept
{ return !(__y < __x); }

bool operator>=(const address_v6& __x, const address_v6& __y) noexcept
{ return !(__x < __y); }

template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
    basic_ostream<CharT, Traits>& os, const address_v6& __addr)
{
    for ( char c : __addr.to_string())
        os << os.widen(c);
    return os;
}


_LIBCPP_END_NAMESPACE_NETWORK_IP

#endif
