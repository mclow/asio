// -*- C++ -*-
//===---------------------------- internet --------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is dual licensed under the MIT and the University of Illinois Open
// Source Licenses. See LICENSE.TXT for details.
//
//  Based on N4332
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_EXPERIMENTAL_INTERNET
#define _LIBCPP_EXPERIMENTAL_INTERNET

/* 
    internet synopsis

namespace std {
  namespace experimental {
    inline namespace network_v1 {
      namespace ip {

        enum class resolver_errc {
          host_not_found = implementation defined, // EAI_NONAME
          host_not_found_try_again = implementation defined, // EAI_AGAIN
          service_not_found = implementation defined // EAI_SERVICE
        };

        const error_category& resolver_category() noexcept;

        error_code make_error_code(resolver_errc e) noexcept;
        error_condition make_error_condition(resolver_errc e) noexcept;

        struct v4_mapped_t {};
        constexpr v4_mapped_t v4_mapped;

        class address;
        class address_v4;
        class address_v6;

        class bad_address_cast;

        // address comparisons:
        bool operator==(const address&, const address&) noexcept;
        bool operator!=(const address&, const address&) noexcept;
        bool operator< (const address&, const address&) noexcept;
        bool operator> (const address&, const address&) noexcept;
        bool operator<=(const address&, const address&) noexcept;
        bool operator>=(const address&, const address&) noexcept;

        // address_v4 comparisons:
        bool operator==(const address_v4&, const address_v4&) noexcept;
        bool operator!=(const address_v4&, const address_v4&) noexcept;
        bool operator< (const address_v4&, const address_v4&) noexcept;
        bool operator> (const address_v4&, const address_v4&) noexcept;
        bool operator<=(const address_v4&, const address_v4&) noexcept;
        bool operator>=(const address_v4&, const address_v4&) noexcept;

        // address_v6 comparisons:
        bool operator==(const address_v6&, const address_v6&) noexcept;
        bool operator!=(const address_v6&, const address_v6&) noexcept;
        bool operator< (const address_v6&, const address_v6&) noexcept;
        bool operator> (const address_v6&, const address_v6&) noexcept;
        bool operator<=(const address_v6&, const address_v6&) noexcept;
        bool operator>=(const address_v6&, const address_v6&) noexcept;

        // address creation:
        address make_address(const char*);
        address make_address(const char*, error_code&) noexcept;
        address make_address(const string_view&);
        address make_address(const string_view&, error_code&) noexcept;

        // address_v4 creation:
        constexpr address_v4 make_address_v4(const address_v4::bytes_type&);
        constexpr address_v4 make_address_v4(unsigned long);
        constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6&);
        address_v4 make_address_v4(const char*);
        address_v4 make_address_v4(const char*, error_code&) noexcept;
        address_v4 make_address_v4(const string_view&);
        address_v4 make_address_v4(const string_view&, error_code&) noexcept;

        // address_v6 creation:
        constexpr address_v6 make_address_v6(const address_v6::bytes_type&, unsigned long = 0);
        constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4&) noexcept;
        address_v6 make_address_v6(const char*);
        address_v6 make_address_v6(const char*, error_code&) noexcept;
        address_v6 make_address_v6(const string_view&);
        address_v6 make_address_v6(const string_view&, error_code&) noexcept;

        // address I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address&);

        // address_v4 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address_v4&);

        // address_v6 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const address_v6&);

        // address conversions:
        template<class T> constexpr T address_cast(const address&) noexcept(see below);
        template<class T> constexpr T address_cast(const address_v4&) noexcept(see below);
        template<class T> constexpr T address_cast(const address_v6&) noexcept(see below);

        class address_iterator_v4;
        class address_iterator_v6;

        class address_range_v4;
        class address_range_v6;

        class network_v4;
        class network_v6;

        // network_v4 comparisons:
        bool operator==(const network_v4&, const network_v4&) noexcept;
        bool operator!=(const network_v4&, const network_v4&) noexcept;

        // network_v6 comparisons:
        bool operator==(const network_v6&, const network_v6&) noexcept;
        bool operator!=(const network_v6&, const network_v6&) noexcept;

        // network_v4 creation:
        network_v4 make_network_v4(const address_v4&, unsigned short);
        network_v4 make_network_v4(const address_v4&, const address_v4&);
        network_v4 make_network_v4(const char*);
        network_v4 make_network_v4(const char*, error_code&) noexcept;
        network_v4 make_network_v4(const string_view&);
        network_v4 make_network_v4(const string_view&, error_code&) noexcept;

        // network_v6 creation:
        network_v6 make_network_v6(const address_v6&, unsigned short);
        network_v6 make_network_v6(const char*);
        network_v6 make_network_v6(const char*, error_code&) noexcept;
        network_v6 make_network_v6(const string_view&);
        network_v6 make_network_v6(const string_view&, error_code&) noexcept;

        // network_v4 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const network_v4&);

        // network_v6 I/O:
        template<class CharT, class Traits>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&, const network_v6&);

        template<class InternetProtocol>
          class basic_endpoint;

        // basic_endpoint comparisons:
        template<class InternetProtocol>
          bool operator==(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator!=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator< (const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator> (const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator<=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);
        template<class InternetProtocol>
          bool operator>=(const basic_endpoint<InternetProtocol>&,
                          const basic_endpoint<InternetProtocol>&);

        // basic_endpoint I/O:
        template<class CharT, class Traits, class InternetProtocol>
          basic_ostream<CharT, Traits>& operator<<(
            basic_ostream<CharT, Traits>&,
            const basic_endpoint<InternetProtocol>&);

        class resolver_query_base;

        template<class InternetProtocol>
          basic_resolver_query;

        template<class InternetProtocol>
          basic_resolver_entry;

        template<class InternetProtocol>
          basic_resolver_iterator;

        template<class InternetProtocol>
          class basic_resolver;

        string host_name();
        string host_name(error_code&);

        class tcp;

        // tcp comparisons:
        bool operator==(const tcp& a, const tcp& b);
        bool operator!=(const tcp& a, const tcp& b);

        class udp;

        // udp comparisons:
        bool operator==(const udp& a, const udp& b);
        bool operator!=(const udp& a, const udp& b);

        class v6_only;

        namespace unicast {

          class hops;

        } // namespace unicast

        namespace multicast {

          class join_group;

          class leave_group;

          class outbound_interface;

          class hops;

          class enable_loopback;

        } // namespace multicast
      } // namespace ip
    } // inline namespace network_v1
  } // namespace experimental

  template<> struct is_error_condition_enum<
    experimental::network_v1::ip::resolver_errc>
      : public true_type {};

  // hash support
  template<class T> struct hash;
  template<> struct hash<experimental::network_v1::ip::address>;
  template<> struct hash<experimental::network_v1::ip::address_v4>;
  template<> struct hash<experimental::network_v1::ip::address_v6>;

} // namespace std      

*/

#include <experimental/__net_config>
#include <system_error> // for error_code
#include <stdexcept>
#include <typeinfo>     // for std::bad_cast
#include <array>
#include <string>
#include <experimental/string_view>

_LIBCPP_BEGIN_NAMESPACE_NETWORK_IP

inline _VSTD_LFTS::string_view
   __make_sv (const char *__s) { return _VSTD_LFTS::string_view{__s, strlen(__s)}; }


class address;
class address_v4;
class address_v6;
class bad_address_cast;
class network_v4;
class network_v6;

struct v4_mapped_t {};
constexpr v4_mapped_t v4_mapped{};

enum class resolver_errc {
    host_not_found = 8,           // EAI_NONAME
    host_not_found_try_again = 2, // EAI_AGAIN
    service_not_found = 9         // EAI_SERVICE
};

const _VSTD::error_category& resolver_category() noexcept;

 _VSTD::error_code make_error_code(resolver_errc __e) noexcept
 { return _VSTD::error_code(static_cast<int>(__e), resolver_category()); }
 
_VSTD::error_condition make_error_condition(resolver_errc __e) noexcept
 { return _VSTD::error_condition(static_cast<int>(__e), resolver_category()); }



template <class _Address>
class _Address_iterator;
typedef _Address_iterator<address_v4> address_iterator_v4;
typedef _Address_iterator<address_v6> address_iterator_v6;

template<class _Tp> constexpr _Tp address_cast(const address&   ) noexcept(_VSTD::is_same<_Tp, address>::value);
template<class _Tp> constexpr _Tp address_cast(const address_v4&) noexcept;
template<class _Tp> constexpr _Tp address_cast(const address_v6&) noexcept;


template <size_t _Sz>
struct __bytes_type : _VSTD::array<unsigned char, _Sz>
    {
        template<class... T> explicit constexpr __bytes_type(T... t)
            : _VSTD::array<unsigned char, _Sz>{{static_cast<unsigned char>(t)...}} {}
//         constexpr __bytes_type(const __bytes_type &__rhs)
//         { memcpy ( &this[0], &__rhs[0], sizeof(*this)); }
// 
//         constexpr __bytes_type& operator=(const __bytes_type &__rhs)
//         {
//             if ( this != &__rhs)
//                 memcpy ( &this[0], &__rhs[0], sizeof(*this));
//             return *this;
//         }
        constexpr bool operator==(const __bytes_type &__rhs) const
        {
        for ( size_t __i = 0; __i < _Sz; ++__i )
            if ((*this)[__i] != __rhs[__i]) return false;
        return true;
        }
        constexpr bool operator<(const __bytes_type &__rhs) const
        {
        for ( size_t __i = 0; __i < _Sz; ++__i )
            if ((*this)[__i] < __rhs[__i]) return true;
        return false;
        }
    };

class _LIBCPP_EXCEPTION_ABI bad_address_cast : public std::bad_cast
{
public:
//  virtual const char* what() const noexcept;
};

class address_v4
    {
public:
    friend address_iterator_v4;
    typedef __bytes_type<4> bytes_type;

    constexpr address_v4() noexcept : __bytes(0,0,0,0) {}
    constexpr address_v4(const address_v4& __rhs) noexcept : __bytes(__rhs.__bytes) {}
    constexpr address_v4(const bytes_type& __b) : __bytes(__b)
    {
#if UCHAR_MAX > 0xFF
    for ( const auto __c : __b )
        if ( __c > 0xFFF ) throw std::out_of_range{"Octet too big in address_v4::address_v4"};
#endif
    }

    explicit constexpr address_v4(unsigned long __v)
        : __bytes {(__v >> 24) & 0xFF, (__v >> 16) & 0xFF, (__v >> 8) & 0xFF, __v & 0xFF}
    {
#if ULONG_MAX > 0xFFFFFFFF
    if ( __v > 0xFFFFFFFF ) throw std::out_of_range{"Long too big in address_v4::address_v4"};
#endif
    }

    address_v4& operator=(const address_v4& __rhs) noexcept
    {
        __bytes = __rhs.__bytes;
        return *this;
    }       

    constexpr bool is_unspecified() const noexcept { return to_ulong() == 0; }
    constexpr bool is_loopback()    const noexcept { return (to_ulong() & 0xFF000000) == 0x7F000000; }
    constexpr bool is_class_a()     const noexcept { return (to_ulong() & 0x80000000) == 0; }
    constexpr bool is_class_b()     const noexcept { return (to_ulong() & 0xC0000000) == 0x80000000; }
    constexpr bool is_class_c()     const noexcept { return (to_ulong() & 0xE0000000) == 0xC0000000; }
    constexpr bool is_multicast()   const noexcept { return (to_ulong() & 0xF0000000) == 0xE0000000; }
    constexpr bytes_type to_bytes() const noexcept { return __bytes; }
    constexpr unsigned long to_ulong() const noexcept {
        unsigned long __val = (((unsigned long)__bytes[0]) << 24) | 
                              (((unsigned long)__bytes[1]) << 16) | 
                              (((unsigned long)__bytes[2]) <<  8) |
                                               __bytes[3];
        return __val;
    }
    
    _VSTD::string to_string() const;

    static constexpr address_v4 any()       noexcept { return address_v4(); }
    static constexpr address_v4 loopback()  noexcept { return address_v4(0x7F000001); }
    static constexpr address_v4 broadcast() noexcept { return address_v4(0xFFFFFFFF); }
    static constexpr address_v4 broadcast( 
        const address_v4& __addr,
        const address_v4& __mask) noexcept { return address_v4(__addr.to_ulong() | ~__mask.to_ulong()); }

   private:
        bytes_type __bytes;
    };

constexpr bool operator==(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return __lhs.to_ulong() == __rhs.to_ulong(); }
constexpr bool operator!=(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return !(__lhs == __rhs); }
constexpr bool operator< (const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return __lhs.to_ulong() < __rhs.to_ulong(); }
constexpr bool operator> (const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return __rhs < __lhs; }
constexpr bool operator<=(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return !(__rhs < __lhs); }
constexpr bool operator>=(const address_v4& __lhs, const address_v4& __rhs) noexcept
{ return !(__lhs < __rhs); }


template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
    basic_ostream<CharT, Traits>& os, const address_v4& __addr)
{
    for ( char c : __addr.to_string())
        os << os.widen(c);
    return os;
}

class address_v6
    {
public:
    typedef __bytes_type<16> bytes_type;
    friend address_iterator_v6;
    
    constexpr address_v6() noexcept
        : __bytes(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0), __scope_id(0) {}
    constexpr address_v6(const address_v6& __rhs) noexcept
        : __bytes(__rhs.__bytes), __scope_id(__rhs.__scope_id)  {}
    constexpr address_v6(const bytes_type& __b, unsigned long scope = 0)
        : __bytes(__b), __scope_id(scope)
    {
#if UCHAR_MAX > 0xFF
    for ( const auto __c : __b )
        if ( __c > 0xFFF ) throw std::out_of_range{"Octet too big in address_v6::address_v6"};
#endif
    }

    address_v6& operator=(const address_v6& __rhs) noexcept
    {
        __bytes    = __rhs.__bytes;
        __scope_id = __rhs.__scope_id;
        return *this;
    }

    void scope_id(unsigned long __id) noexcept        { __scope_id = __id; }
    constexpr unsigned long scope_id() const noexcept { return __scope_id; }

    constexpr bool is_unspecified() const noexcept
    {
//     for ( auto const c : __bytes )
//         if ( c != 0 ) return false;
    for ( size_t __i = 0; __i < 16; ++__i )
        if ( __bytes[__i] != 0 ) return false;
    return true;
    }
  
    constexpr bool is_loopback() const noexcept
    {
    for ( size_t i = 0; i < 15; ++i )
        if ( __bytes[i] != 0 ) return false;
    return __bytes[15] == 1;
    }

    constexpr bool is_multicast()  const noexcept { return __bytes[0] == 0xFF; }
    constexpr bool is_link_local() const noexcept { return __bytes[0] == 0xFE && (__bytes[1] & 0xC0) == 0x80; }
    constexpr bool is_site_local() const noexcept { return __bytes[0] == 0xFE && (__bytes[1] & 0xC0) == 0xC0; }
    constexpr bool is_v4_mapped()  const noexcept
    { 
    for ( size_t i = 0; i < 10; ++i )
        if ( __bytes[i] != 0 ) return false;
    return __bytes[10] == 0xFF && __bytes[11] == 0xFF;
    }

    constexpr bool is_multicast_node_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x01; }
    constexpr bool is_multicast_link_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x02; }
    constexpr bool is_multicast_site_local() const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x05; }
    constexpr bool is_multicast_org_local()  const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x08; }
    constexpr bool is_multicast_global()     const noexcept { return __bytes[0] == 0xFF && (__bytes[1] & 0x0F) == 0x0E; }

    constexpr bytes_type to_bytes() const noexcept { return __bytes; }
    _VSTD::string to_string() const;

  // static members:
  static constexpr address_v6 any() noexcept { return address_v6(); }
  static constexpr address_v6 loopback() noexcept
  { return address_v6(address_v6::bytes_type{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1}); }
  
private:
    bytes_type __bytes;
    unsigned long __scope_id;
    };

inline constexpr address_v4 make_address_v4(const address_v4::bytes_type& __b)
{ return address_v4(__b); }

inline constexpr address_v4 make_address_v4(unsigned long __v)
{ return address_v4(__v); }

address_v4 make_address_v4(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept;

inline address_v4 make_address_v4(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address_v4 addr = make_address_v4(__sv, __ec);
    if (__ec) throw __ec;
    return addr;
}

inline address_v4 make_address_v4(const char* __s)
{ return make_address_v4(__make_sv(__s)); }

inline address_v4 make_address_v4(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address_v4(__make_sv(__s), __ec); }


inline constexpr address_v4 make_address_v4(v4_mapped_t, const address_v6& __a)
{
    if (!__a.is_v4_mapped()) throw bad_address_cast{};
    const address_v6::bytes_type __6bytes{__a.to_bytes()};
    address_v4::bytes_type __4bytes{__6bytes[12], __6bytes[13], __6bytes[14], __6bytes[15]};
    return address_v4(__4bytes);
}


inline constexpr address_v6 make_address_v6(const address_v6::bytes_type& __bytes, unsigned long __id = 0)
{ return address_v6(__bytes, __id); }

inline constexpr address_v6 make_address_v6(v4_mapped_t, const address_v4& __a) noexcept
{
    const address_v4::bytes_type __4bytes{__a.to_bytes()};
    address_v6::bytes_type __6bytes{ 0, 0, 0, 0, 0, 0, 0, 0,
                  0, 0, 0xFF, 0xFF, __4bytes[0], __4bytes[1], __4bytes[2], __4bytes[3] };
  return address_v6(__6bytes);
}

address_v6 make_address_v6(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept;

inline address_v6 make_address_v6(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address_v6 addr = make_address_v6(__sv, __ec);
    if (__ec) throw __ec;
    return addr;
}   

inline address_v6 make_address_v6(const char* __s)
{ return make_address_v6(__make_sv(__s)); }

inline address_v6 make_address_v6(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address_v6(__make_sv(__s), __ec); }


constexpr bool operator==(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return (__lhs.scope_id() == __rhs.scope_id()) && (__lhs.to_bytes() == __rhs.to_bytes()); }
constexpr bool operator!=(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return !(__lhs == __rhs); }
constexpr bool operator< (const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return __lhs.to_bytes() < __rhs.to_bytes() || (!(__rhs.to_bytes() < __lhs.to_bytes()) && __lhs.scope_id() < __rhs.scope_id()); }
constexpr bool operator> (const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return __rhs < __lhs; }
constexpr bool operator<=(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return !(__rhs < __lhs); }
constexpr bool operator>=(const address_v6& __lhs, const address_v6& __rhs) noexcept
{ return !(__lhs < __rhs); }

template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
basic_ostream<CharT, Traits>& __os, const address_v6& __addr)
{
    for ( char c : __addr.to_string())
        __os << __os.widen(c);
    return __os;
}

class address
{
private:
    enum class _Address { __ip_none, __ipv4, __ipv6 };
    _Address __atype;
    address_v4 __v4;
    address_v6 __v6;

public:
    constexpr address() noexcept : __atype(_Address::__ip_none), __v4(), __v6() {}
    constexpr address(const address& __rhs) noexcept :
        __atype(__rhs.__atype), __v4(__rhs.__v4), __v6(__rhs.__v6) {}
    
//  template<class _Tp>
//  constexpr address(const _Tp& __t,
//      typename enable_if<
//          !_VSTD::is_same<_Tp, address>::value && 
//           _VSTD::is_same<address &, decltype(address_cast<address>(_Tp()))>::value>::type* = 0)
//       noexcept(address_cast<address>(_Tp())) : address(address_cast<address>(__t)) {}

    explicit constexpr address(const address_v4 &__rhs) noexcept :
        __atype(_Address::__ipv4), __v4(__rhs), __v6() {}
    explicit constexpr address(const address_v6 &__rhs) noexcept :
        __atype(_Address::__ipv6), __v4(), __v6(__rhs) {}

    address& operator=(const address& __rhs) noexcept
    {
        __atype = __rhs.__atype;
        __v4 = __rhs.__v4;
        __v6 = __rhs.__v6;
        return * this;
    }

    constexpr bool is_unspecified() const noexcept
    {
        if (is_v4()) return __v4.is_unspecified();
        if (is_v6()) return __v6.is_unspecified();
        return false;
    }
    
    constexpr bool is_loopback() const noexcept
    {
        if (is_v4()) return __v4.is_loopback();
        if (is_v6()) return __v6.is_loopback();
        return false;
    }

    constexpr bool is_multicast() const noexcept
    {
        if (is_v4()) return __v4.is_multicast();
        if (is_v6()) return __v6.is_multicast();
        return false;
    }

    constexpr bool is_v4() const noexcept { return __atype == _Address::__ipv4; }
    constexpr bool is_v6() const noexcept { return __atype == _Address::__ipv6; }

    _VSTD::string to_string() const
    {
        if (is_v4()) return __v4.to_string();
        if (is_v6()) return __v6.to_string();
        throw bad_address_cast{};
    }

    constexpr bool __equal(const address& __rhs) const // TODO
    {
//  They're the same type
    if (__atype == _Address::__ip_none && __rhs.__atype == _Address::__ip_none) return true;
    if (is_v4() && __rhs.is_v4()) return __v4 == __rhs.__v4;
    if (is_v6() && __rhs.is_v6()) return __v6 == __rhs.__v6;

//  One of them is empty
    if (__atype == _Address::__ip_none && __rhs.is_v4()) return address_v4() == __rhs.__v4;
    if (is_v4() && __rhs.__atype == _Address::__ip_none) return __v4 == address_v4();
    if (__atype == _Address::__ip_none && __rhs.is_v6()) return address_v6() == __rhs.__v6;
    if (is_v6() && __rhs.__atype == _Address::__ip_none) return __v6 == address_v6();

    return is_v4()
        ? make_address_v6(v4_mapped, __v4) == __rhs.__v6
        : __v6 == make_address_v6(v4_mapped, __rhs.__v4);
    }

    constexpr bool __less (const address& __rhs) const { return true; } // TODO
    constexpr address_v4 __get_v4 () const noexcept { return __v4; }
    constexpr address_v6 __get_v6 () const noexcept { return __v6; }
    };
    

// address comparisons:
constexpr bool operator==(const address& __lhs, const address& __rhs) noexcept
{ return __lhs.__equal(__rhs); }
constexpr bool operator!=(const address& __lhs, const address& __rhs) noexcept
{ return !(__lhs == __rhs); }
constexpr bool operator< (const address& __lhs, const address& __rhs) noexcept
{ return __lhs.__less(__rhs); }
constexpr bool operator> (const address& __lhs, const address& __rhs) noexcept
{ return __rhs < __lhs; }
constexpr bool operator<=(const address& __lhs, const address& __rhs) noexcept
{ return !(__rhs < __lhs); }
constexpr bool operator>=(const address& __lhs, const address& __rhs) noexcept
{ return !(__lhs < __rhs); }

// address creation:
inline address make_address(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept
{
    address_v6 __v6 = make_address_v6(__sv, __ec);
    if (!__ec)
     return address(__v6);
    address_v4 __v4 = make_address_v4(__sv, __ec);
    return !__ec ? address(__v4) : address ();
}

inline address make_address(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    address __a = make_address(__sv, __ec);
    if (__ec) throw __ec;
    return __a;
}

inline address make_address(const char* __s) { return make_address(__make_sv(__s)); }
inline address make_address(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_address(__make_sv(__s), __ec); }


// address I/O:
template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(basic_ostream<CharT, Traits>& __os, const address& __a)
{
    for ( const char __c : __a.to_string())
        __os << __os.widen(__c);
    return __os;
}

// template <class _Tp, class _Head, class... _Tail>
// struct __contains0 {
//  static const bool value = __contains0<_Tp, _Head>::value
//                         || __contains0<_Tp, _Tail...>::value;
// };
// 
// template <class _Tp, class _Head>
// struct __contains0<_Tp, _Head> {
//  static const bool value = std::is_same<_Head, _Tp>::value;
// };
// 
// template <class _Tp, class... _TypeList>
// struct __contains : public _VSTD::integral_constant<bool, __contains0<_Tp, _TypeList...>::value> {};
// 
// template <class _Tp>
// struct __is_address : public __contains<_Tp, address, address_v4, address_v6> {};


// template<class _Tp> constexpr _Tp address_cast(const address& __a)
template<> constexpr address    address_cast(const address&    __a) noexcept { return __a; }
template<> constexpr address_v4 address_cast(const address& __a) noexcept(false)
{
    if (!__a.is_v4()) throw bad_address_cast{};
    return __a.__get_v4();
}

template<> constexpr address_v6 address_cast(const address& __a) noexcept(false)
{
    if (!__a.is_v6()) throw bad_address_cast{};
    return __a.__get_v6();
}

// template<class _Tp> constexpr _Tp address_cast(const address_v4&) noexcept;
template<> constexpr address    address_cast(const address_v4& __a) noexcept { return address(__a); }
template<> constexpr address_v4 address_cast(const address_v4& __a) noexcept { return __a; }
template<> constexpr address_v6 address_cast(const address_v4& __a) noexcept = delete;

// template<class _Tp> constexpr _Tp address_cast(const address_v6&) noexcept;
template<> constexpr address    address_cast(const address_v6& __a) noexcept { return address(__a); }
template<> constexpr address_v4 address_cast(const address_v6& __a) noexcept = delete;
template<> constexpr address_v6 address_cast(const address_v6& __a) noexcept { return __a; }

template <class _Address>
class _Address_iterator
{
public:
    typedef _Address                  value_type;
    typedef ptrdiff_t                 difference_type;
    typedef const _Address*           pointer;
    typedef const _Address&           reference;
    typedef _VSTD::input_iterator_tag iterator_category;

    _Address_iterator() noexcept : __address() {}
    _Address_iterator(const _Address& __a) noexcept : __address(__a) {}

    reference operator*()  const noexcept { return __address; }
    pointer   operator->() const noexcept { return &__address; }

    _Address_iterator& operator++() noexcept
    {
        for (auto it = __address.__bytes.rbegin(); it != __address.__bytes.rend(); ++it) {
            if ( *it < 255 ) {
                ++*it;
                break;
                }
            *it = 0;
            }
        return *this;
    }

    _Address_iterator operator++(int) noexcept
    {
        _Address_iterator __prev = *this;
        ++*this;
        return __prev;
    }

    _Address_iterator& operator--() noexcept {
        for (auto it = __address.__bytes.rbegin(); it != __address.__bytes.rend(); ++it) {
            if ( *it > 0 ) {
                --*it;
                break;
                }
            *it = 255;
        }
        return *this;
    }
    
    _Address_iterator  operator--(int) noexcept
    {
        _Address_iterator __prev = *this;
        --*this;
        return __prev;
    }

    bool operator==(const _Address_iterator & __rhs) const noexcept
    { return __address == __rhs.__address; }
    bool operator!=(const _Address_iterator & __rhs) const noexcept
    { return !(__address == __rhs.__address); }

private:
    _Address __address;
};

class address_range_v4
{
public:
    typedef address_v4          address_type;
    typedef address_iterator_v4 iterator;

    // constructors:
    address_range_v4() noexcept : __b(), __e() {}
    address_range_v4(const address_type& __f, const address_type& __l) noexcept :
        __b(__f), __e(__l) {}

    iterator begin() const noexcept { return __b; }
    iterator end() const noexcept   { return __e; }
    bool empty() const noexcept     { return __b == __e; }

    size_t size() const noexcept { return __e->to_ulong() - __b->to_ulong(); }
    iterator find(const address_type& __a) const noexcept
    { return (*__b <= __a && __a < *__e) ? iterator(__a) : __e; }
        
private:
    iterator __b;
    iterator __e;
};

class address_range_v6
{
public:
    typedef address_v6          address_type;
    typedef address_iterator_v6 iterator;

    // constructors:
    address_range_v6() noexcept : __b(), __e() {}
    address_range_v6(const address_type& __f, const address_type& __l) noexcept :
        __b(__f), __e(__l) {}

    iterator begin() const noexcept { return __b; }
    iterator end() const noexcept   { return __e; }
    bool empty() const noexcept     { return __b == __e; }

    iterator find(const address_type& __a) const noexcept
    { return (*__b <= __a && __a < *__e) ? iterator(__a) : __e; }
        
private:
    iterator __b;
    iterator __e;
};


class network_v4
{
public:
    network_v4() noexcept : __addr{}, __prefix{0} {}
    network_v4(const address_v4& __a, unsigned short __p) : __addr{__a}, __prefix{__p}
    { if (__p > 24) throw std::out_of_range{"Prefix too big in network_v4::network_v4"}; }
//  network_v4(const address_v4& addr, const address_v4& mask); // TODO

    address_v4 address() const noexcept { return __addr; }
    unsigned short prefix_length() const noexcept { return __prefix; }
    address_v4 netmask() const noexcept { return address_v4{__get_prefix_bits(__prefix)}; }
    inline address_v4 network() const noexcept
    {
        address_v4::bytes_type __ret = __addr.to_bytes();
        address_v4::bytes_type __b = __get_prefix_bits(__prefix);
        for ( unsigned __i = 0; __i < __b.size(); ++__i )
            __ret[__i] &= __b[__i];
        return address_v4(__ret);
    }

    address_v4 broadcast() const noexcept
    {
        address_v4::bytes_type __ret = __addr.to_bytes();
        address_v4::bytes_type __b = __get_prefix_bits(__prefix);
        for ( unsigned __i = 0; __i < __b.size(); ++__i )
            __ret[__i] |= ~__b[__i];
        return address_v4(__ret);
    }

    address_range_v4 hosts() const noexcept
    { return address_range_v4{__addr, address_v4{__addr.to_ulong() + __num_addrs()}}; }
    
    network_v4 canonical() const noexcept { return network_v4{network(), prefix_length()}; }
    bool       is_host()   const noexcept { return __prefix == 32; }
    bool is_subnet_of(const network_v4& other) const noexcept;
    _VSTD::string to_string() const;
private:
    address_v4     __addr;
    unsigned short __prefix;

    static address_v4::bytes_type __get_prefix_bits(short __p)
    {
        address_v4::bytes_type __b{0,0,0,0};
        for ( int __i = 0; __i < __b.size() && __p > 0; __i++, __p -= 8 )
            __b[__i] = __p >= 8 ? 0xFF : (0xFF00 >> __p) & 0x00FF;
        return __b;
    }

    size_t __num_addrs() const { return is_host() ? 1 : 0xFFFFFFFF >> prefix_length(); }
    };

inline bool operator==(const network_v4& __lhs, const network_v4& __rhs) noexcept
{ return __lhs.address() == __rhs.address() && __lhs.prefix_length () == __rhs.prefix_length(); }

inline bool operator!=(const network_v4& __lhs, const network_v4& __rhs) noexcept
{ return !(__lhs == __rhs); }

// network_v4 creation:
inline network_v4 make_network_v4(const address_v4& __a, unsigned short __p)
{ return network_v4(__a, __p); }

// inline network_v4 make_network_v4(const address_v4& __a, const address_v4& __m)
// { return network_v4(__a, __m); }

network_v4 make_network_v4(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept;

inline network_v4 make_network_v4(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    network_v4 __a = make_network_v4(__sv, __ec);
    if (__ec) throw __ec;
    return __a;
}

inline network_v4 make_network_v4(const char* __s) { return make_network_v4(__make_sv(__s)); }
inline network_v4 make_network_v4(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_network_v4(__make_sv(__s), __ec); }

// network_v4 I/O:
template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
basic_ostream<CharT, Traits>& __os, const network_v4& __net)
{
    for ( char c : __net.to_string())
        __os << __os.widen(c);
    return __os;
}

bool operator==(const network_v6& __lhs, const network_v6& __rhs) noexcept;
bool operator!=(const network_v6& __lhs, const network_v6& __rhs) noexcept;

class network_v6
{
public:
    // constructors:
    network_v6() noexcept : __addr{}, __prefix{0} {}
    network_v6(const address_v6& __a, unsigned short __p) : __addr{__a}, __prefix{__p} {}

    // members:
    address_v6     address()       const noexcept { return __addr; }
    unsigned short prefix_length() const noexcept { return __prefix; }
    address_v6 network() const noexcept
    {
        address_v6::bytes_type __ret = __addr.to_bytes();
        address_v6::bytes_type __b = __get_prefix_bits(__prefix);
        for ( unsigned __i = 0; __i < __b.size(); ++__i )
            __ret[__i] &= __b[__i];
        return address_v6(__ret);
    }

    address_range_v6 hosts() const noexcept
    {
        address_v6::bytes_type __a = address().to_bytes();
        address_v6::bytes_type __inc = __get_count_bytes(__prefix);
        unsigned __carry = 0;
        for ( int __i = __a.size() - 1; __i >= 0; --__i )
        {
            unsigned __val = __a[__i] + __inc[__i] + __carry;
            __carry = __val > 255;
            __a[__i] = __val & 0x00FF;
        }
        return address_range_v6{address(), address_v6{__a}};
    }
    
    network_v6 canonical() const noexcept { return network_v6(network(), prefix_length()); }
    bool is_host() const noexcept { return __prefix == 128; }
    bool is_subnet_of(const network_v6& __o) const noexcept
    {
        return __o.prefix_length() < prefix_length() && 
              network_v6(address(), __o.prefix_length()).canonical() == __o.canonical();
    }

    _VSTD::string to_string() const;

private:
    address_v6     __addr;
    unsigned short __prefix;

    static address_v6::bytes_type __get_prefix_bits(short __p)
    {
        address_v6::bytes_type __b{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        for ( int __i = 0; __i < __b.size() && __p > 0; __i++, __p -= 8 )
            __b[__i] = __p >= 8 ? 0xFF : (0xFF00 >> __p) & 0x00FF;
        return __b;
    }

    static address_v6::bytes_type __get_count_bytes(short __p)
    {
        address_v6::bytes_type __b{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
        for ( int __i = __b.size() - 1; __i >= 0 && __p > 0; --__i, __p -= 8 )
            __b[__i] = __p >= 8 ? 0xFF : (0xFF00 >> __p) & 0x00FF;

        return __b;
    }
};

inline bool operator==(const network_v6& __lhs, const network_v6& __rhs) noexcept
{ return __lhs.address() == __rhs.address() && __lhs.prefix_length () == __rhs.prefix_length(); }

inline bool operator!=(const network_v6& __lhs, const network_v6& __rhs) noexcept
{ return !(__lhs == __rhs); }

// network_v6 creation:
inline network_v6 make_network_v6(const address_v6& __a, unsigned short __p)
{ return network_v6(__a, __p); }

network_v6 make_network_v6(_VSTD_LFTS::string_view __sv, _VSTD::error_code& __ec) noexcept;
inline network_v6 make_network_v6(_VSTD_LFTS::string_view __sv)
{
    _VSTD::error_code __ec;
    network_v6 __a = make_network_v6(__sv, __ec);
    if (__ec) throw __ec;
    return __a;
}

inline network_v6 make_network_v6(const char* __s) { return make_network_v6(__make_sv(__s)); }
inline network_v6 make_network_v6(const char* __s, _VSTD::error_code& __ec) noexcept
{ return make_network_v6(__make_sv(__s), __ec); }

// network_v6 I/O:
template<class CharT, class Traits>
basic_ostream<CharT, Traits>& operator<<(
basic_ostream<CharT, Traits>& __os, const network_v6& __net)
{
    for ( char c : __net.to_string())
        __os << __os.widen(c);
    return __os;
}


template<class _InternetProtocol>
class basic_endpoint
{
public:
// types:
    typedef _InternetProtocol         protocol_type;
    typedef _VSTD_NETWORK_IP::address address_type;
    typedef unsigned short            port_type;

// constructors:
    basic_endpoint() : __addr{address_v4{}}, __port{0} {}
    basic_endpoint(const protocol_type& __proto, port_type __p)
        : __addr{__proto == protocol_type::v6() ? address_type{address_v6{}} : address_type{address_v4{}}},
          __port{__p} {}
    basic_endpoint(const address_type& __a, port_type __p)
        : __addr{__a}, __port{__p} {}
        
// members:
    protocol_type protocol() const { return __addr.is_v6() ? protocol_type::V6() : protocol_type::V4(); }
    address_type address() const          { return __addr; }
    void address(const address_type& __a) { __addr = __a; }
    port_type port() const                { return __port; }
    void port(port_type __p)              { __port = __p; }
private:
    address_type __addr;
    port_type __port;
    
/*
    unspecified* data();
    const unspecified* data() const;
    size_t size() const;
    void resize(size_t s);
    size_t capacity() const;
    // remainder unchanged
    private:
    //        sockaddr_storage data_;  exposition only
*/

};

// basic_endpoint comparisons:
template<class _InternetProtocol>
bool operator==(const basic_endpoint<_InternetProtocol>& __lhs,
                const basic_endpoint<_InternetProtocol>& __rhs)
{ return __lhs.address() == __rhs.address() && __lhs.port() == __rhs.port(); }

template<class _InternetProtocol>
bool operator!=(const basic_endpoint<_InternetProtocol>& __lhs,
                const basic_endpoint<_InternetProtocol>& __rhs) { return !(__lhs == __rhs); }

template<class _InternetProtocol>
bool operator< (const basic_endpoint<_InternetProtocol>& __lhs,
                const basic_endpoint<_InternetProtocol>& __rhs)
{ __lhs.address() < __rhs.address() || (!(__rhs.address() < __lhs.address()) && __lhs.port() < __rhs.port()); }

template<class _InternetProtocol>
bool operator> (const basic_endpoint<_InternetProtocol>& __lhs,
                const basic_endpoint<_InternetProtocol>& __rhs) { return __rhs < __lhs; }

template<class _InternetProtocol>
bool operator<=(const basic_endpoint<_InternetProtocol>& __lhs,
                const basic_endpoint<_InternetProtocol>& __rhs) { return !(__rhs < __lhs); }

template<class _InternetProtocol>
bool operator>=(const basic_endpoint<_InternetProtocol>& __lhs,
                const basic_endpoint<_InternetProtocol>& __rhs) { return (!__lhs < __rhs); }

// basic_endpoint I/O:
template<class CharT, class Traits, class _InternetProtocol>
basic_ostream<CharT, Traits>& operator<<( basic_ostream<CharT, Traits>& __os,
                                          const basic_endpoint<_InternetProtocol>& __ep)
{
    if ( __ep.protocol() == _InternetProtocol::V6())
        __os << __os.widen('[') << __ep.address() << __os.widen(']');
    else
        __os << __ep.address();
    __os << __os.widen(':') << __ep.port();
    return __os;
}

class resolver_query_base
{
public:
    typedef uint32_t flags;
    static const flags passive            = 0x00000001; /* AI_PASSIVE */
    static const flags canonical_name     = 0x00000002; /* AI_CANONNAME */
    static const flags numeric_host       = 0x00000004; /* AI_NUMERICHOST */ 
    static const flags numeric_service    = 0x00001000; /* AI_NUMERICSERV */
    static const flags v4_mapped          = 0x00000800; /* AI_V4MAPPED */
    static const flags all_matching       = 0x00000100; /* AI_ALL */
    static const flags address_configured = 0x00000400; /* AI_ADDRCONFIG */

protected:
    resolver_query_base() {}
    ~resolver_query_base() {}
};

template<class _InternetProtocol>
class basic_resolver_entry
{
public:
    typedef _InternetProtocol                    protocol_type;
    typedef typename _InternetProtocol::endpoint endpoint_type;

    basic_resolver_entry()
        : __endpoint{basic_endpoint<_InternetProtocol>{}}, __host{}, __service{} {}
    basic_resolver_entry(const endpoint_type& __ep, 
                            _VSTD_LFTS::string_view __h, _VSTD_LFTS::string_view __s)
        : __endpoint{__ep}, __host{__h.begin(), __h.end()}, __service{__s.begin(), __s.end()} {}

    endpoint_type endpoint() const      { return __endpoint; }
    operator endpoint_type() const      { return __endpoint; }
    _VSTD::string host_name() const     { return __host; }
    _VSTD::string service_name() const  { return __service; }
private:
    endpoint_type   __endpoint;
    _VSTD::string   __host;
    _VSTD::string   __service;
    };

#if 0
//  This is missing some stuff in the doc; like how to get info out of the object.
template<class _InternetProtocol>
class basic_resolver_query : public resolver_query_base
{
public:
    typedef _InternetProtocol protocol_type;

    basic_resolver_query();
    basic_resolver_query(_VSTD_LFTS::string_view __s,
                         flags __f = passive | address_configured);
    basic_resolver_query(const InternetProtocol& __p, _VSTD_LFTS::string_view __s, 
                         flags __f = passive | address_configured);
    basic_resolver_query(_VSTD_LFTS::string_view __h, _VSTD_LFTS::string_view __s, 
                         flags __f = address_configured);
    basic_resolver_query(const InternetProtocol& __p, _VSTD_LFTS::string_view __h,
                         _VSTD_LFTS::string_view __s, flags __f = address_configured);
private:
    _VSTD::string __host;
    _VSTD::string __service;
};

//  There's a lot missing here, too.
template<class _InternetProtocol>
class basic_resolver_iterator
{
public:
// types:
    typedef basic_resolver_entry<_InternetProtocol>        value_type;
    typedef ptrdiff_t                                      difference_type;
    typedef const basic_resolver_entry<_InternetProtocol>* pointer;
    typedef const basic_resolver_entry<_InternetProtocol>& reference;
    typedef forward_iterator_tag                           iterator_category;
    typedef _InternetProtocol                              protocol_type;
    typedef typename _InternetProtocol::endpoint           endpoint_type;

    basic_resolver_iterator();

// other members as required by C++ Std [forward.iterators]
    reference operator*() const;
    pointer   operator->() const;
    basic_resolver_iterator& operator++();
    basic_resolver_iterator& operator++(int); // should this be '&'
    
};

template<class _InternetProtocol>
bool
operator==(const basic_resolver_iterator<_InternetProtocol>& __lhs, basic_resolver_iterator<_InternetProtocol>& __rhs);

template<class _InternetProtocol>
bool
operator!=(const basic_resolver_iterator<_InternetProtocol>& __lhs, basic_resolver_iterator<_InternetProtocol>& __rhs)
{ return !(__lhs == __rhs); }



template<class _InternetProtocol>
class basic_resolver
{
public:
    typedef io_service::executor_type                  executor_type;
    typedef _InternetProtocol                          protocol_type;
    typedef typename _InternetProtocol::endpoint       endpoint_type;
    typedef basic_resolver_query<_InternetProtocol>    query;
    typedef basic_resolver_iterator<_InternetProtocol> iterator;

// construct / copy / destroy:

    explicit basic_resolver(io_service& ios);
    basic_resolver(const basic_resolver&) = delete;
    basic_resolver(basic_resolver&& rhs);

    ~basic_resolver();

    basic_resolver& operator=(const basic_resolver&) = delete;
    basic_resolver& operator=(basic_resolver&& rhs);

    executor_type get_executor() noexcept;
    void cancel();

    iterator resolve(const query& q);
    iterator resolve(const query& q, error_code& ec);

    template<class CompletionToken>
    auto async_resolve(const query& q, CompletionToken&& token);

    iterator resolve(const endpoint_type& e);
    iterator resolve(const endpoint_type& e, error_code& ec);

    template<class CompletionToken>
    auto async_resolve(const endpoint_type& e, CompletionToken&& token);
};



template<class InternetProtocol>  class basic_resolver;
template<class InternetProtocol>  class basic_stream_socket;
template<class InternetProtocol>  class basic_socket_acceptor;
template<class InternetProtocol>  class basic_socket_iostream;

class tcp
{
public:
    typedef basic_endpoint<tcp>        endpoint;
    typedef basic_resolver<tcp>        resolver;
    typedef basic_stream_socket<tcp>   socket;
    typedef basic_socket_acceptor<tcp> acceptor;
    typedef basic_socket_iostream<tcp> iostream;
//  class no_delay; // TODO

    int family()   const;
    int type()     const;
    int protocol() const;

    static tcp v4();
    static tcp v6();

private:
    tcp(); // not defined
};

// tcp comparisons:
bool operator==(const tcp& __lhs, const tcp& __rhs);
bool operator!=(const tcp& __lhs, const tcp& __rhs);

class udp
{
public:

    typedef basic_endpoint<udp>        endpoint;
    typedef basic_resolver<udp>        resolver;
    typedef basic_datagram_socket<udp> socket;

    int family()   const;
    int type()     const;
    int protocol() const;

    static udp v4();
    static udp v6();

private:
    udp(); // not defined
};

// udp comparisons:
bool operator==(const udp& __lhs, const udp& __rhs);
bool operator!=(const udp& __lhs, const udp& __rhs);

#endif


_LIBCPP_END_NAMESPACE_NETWORK_IP

#endif
